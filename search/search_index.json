{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udd10 aioauth","text":"<p>aioauth is a spec-compliant OAuth 2.0 asynchronous Python module. aioauth works out-of-the-box with asynchronous server frameworks like FastAPI, Starlette, aiohttp, and others, as well as asynchronous database modules like Motor (MongoDB), aiopg (PostgreSQL), aiomysql (MySQL), or ORMs like Gino, sqlalchemy, or Tortoise.</p> <p>The magic of aioauth is its plug-and-play methods that allow the use of virtually any server or database framework.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install aioauth\n</code></pre> <p>To install pre-releases:</p> <pre><code>pip install git+https://github.com/aliev/aioauth\n</code></pre>"},{"location":"#supported-rfc","title":"Supported RFC","text":"<p>aioauth supports the following RFCs:</p> <ul> <li>RFC 6749 - The OAuth 2.0 Authorization Framework</li> <li>RFC 7662 - OAuth 2.0 Token Introspection</li> <li>RFC 7636 - Proof Key for Code Exchange by OAuth Public Clients</li> </ul>"},{"location":"#pages","title":"Pages","text":"<ul> <li>Github Project</li> <li>Issues</li> <li>Discussion</li> </ul>"},{"location":"sections/api/collections/","title":"Collections","text":"<p>Collections that are used throughout the project. <pre><code>from aioauth import collections\n</code></pre></p>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict","title":"<code>HTTPHeaderDict</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>A dict-like container for storing HTTP headers with case-insensitive keys.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Optional[Mapping[str, str]]</code> <p>An iterable of field-value pairs. Must not contain duplicate field names (case-insensitively).</p> <code>None</code> <code>**kwargs</code> <p>Additional key-value pairs passed to <code>dict.update</code>.</p> <code>{}</code> Example <pre><code>from aioauth.collections import HTTPHeaderDict\nd = HTTPHeaderDict({\"hello\": \"world\"})\nprint(d['hello'])  # &gt;&gt;&gt; 'world'\nprint(d['Hello'])  # &gt;&gt;&gt; 'world'\nprint(d['hElLo'])  # &gt;&gt;&gt; 'world'\n</code></pre> Source code in <code>aioauth/collections.py</code> <pre><code>class HTTPHeaderDict(UserDict):\n    \"\"\"\n    A dict-like container for storing HTTP headers with case-insensitive keys.\n\n    Args:\n        headers (Optional[Mapping[str, str]]):\n            An iterable of field-value pairs. Must not contain duplicate field\n            names (case-insensitively).\n        **kwargs:\n            Additional key-value pairs passed to `dict.update`.\n\n    Example:\n        ```python\n        from aioauth.collections import HTTPHeaderDict\n        d = HTTPHeaderDict({\"hello\": \"world\"})\n        print(d['hello'])  # &gt;&gt;&gt; 'world'\n        print(d['Hello'])  # &gt;&gt;&gt; 'world'\n        print(d['hElLo'])  # &gt;&gt;&gt; 'world'\n        ```\n    \"\"\"\n\n    def __init__(self, headers=None, **kwargs):\n        \"\"\"Initialize the case-insensitive dictionary.\"\"\"\n        super().__init__(headers, **kwargs)\n        self.data = {k.lower(): v for k, v in self.data.items()}\n\n    def __setitem__(self, key: str, value: str):\n        \"\"\"Set a key-value pair with case-insensitive key.\"\"\"\n        super().__setitem__(key.lower(), value)\n\n    def __getitem__(self, key: str):\n        \"\"\"Retrieve a value by case-insensitive key.\"\"\"\n        return super().__getitem__(key.lower())\n\n    def __delitem__(self, key: str):\n        \"\"\"Delete a key-value pair using a case-insensitive key.\"\"\"\n        return super().__delitem__(key.lower())\n\n    def get(self, key: str, default: Any = None):\n        \"\"\"\n        Return the value for key if key is in the dictionary, else default.\n\n        Args:\n            key (str): The key to search for (case-insensitive).\n            default (Any, optional): The value to return if key is not found.\n\n        Returns:\n            Any: The value associated with the key, or default if not found.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n</code></pre>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete a key-value pair using a case-insensitive key.</p> Source code in <code>aioauth/collections.py</code> <pre><code>def __delitem__(self, key: str):\n    \"\"\"Delete a key-value pair using a case-insensitive key.\"\"\"\n    return super().__delitem__(key.lower())\n</code></pre>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve a value by case-insensitive key.</p> Source code in <code>aioauth/collections.py</code> <pre><code>def __getitem__(self, key: str):\n    \"\"\"Retrieve a value by case-insensitive key.\"\"\"\n    return super().__getitem__(key.lower())\n</code></pre>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict.__init__","title":"<code>__init__(headers=None, **kwargs)</code>","text":"<p>Initialize the case-insensitive dictionary.</p> Source code in <code>aioauth/collections.py</code> <pre><code>def __init__(self, headers=None, **kwargs):\n    \"\"\"Initialize the case-insensitive dictionary.\"\"\"\n    super().__init__(headers, **kwargs)\n    self.data = {k.lower(): v for k, v in self.data.items()}\n</code></pre>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set a key-value pair with case-insensitive key.</p> Source code in <code>aioauth/collections.py</code> <pre><code>def __setitem__(self, key: str, value: str):\n    \"\"\"Set a key-value pair with case-insensitive key.\"\"\"\n    super().__setitem__(key.lower(), value)\n</code></pre>"},{"location":"sections/api/collections/#aioauth.collections.HTTPHeaderDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for key if key is in the dictionary, else default.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to search for (case-insensitive).</p> required <code>default</code> <code>Any</code> <p>The value to return if key is not found.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The value associated with the key, or default if not found.</p> Source code in <code>aioauth/collections.py</code> <pre><code>def get(self, key: str, default: Any = None):\n    \"\"\"\n    Return the value for key if key is in the dictionary, else default.\n\n    Args:\n        key (str): The key to search for (case-insensitive).\n        default (Any, optional): The value to return if key is not found.\n\n    Returns:\n        Any: The value associated with the key, or default if not found.\n    \"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"sections/api/config/","title":"Config","text":"<p>Configuration settings for aioauth server instance.</p> <pre><code>from aioauth import config\n</code></pre>"},{"location":"sections/api/config/#aioauth.config.Settings","title":"<code>Settings</code>  <code>dataclass</code>","text":"<p>Configuration options that is used by the Server class.</p> Source code in <code>aioauth/config.py</code> <pre><code>@dataclass\nclass Settings:\n    \"\"\"Configuration options that is used by the Server class.\"\"\"\n\n    TOKEN_EXPIRES_IN: int = 24 * 60 * 60\n    \"\"\"Access token lifetime in seconds. Defaults to 24 hours.\"\"\"\n\n    REFRESH_TOKEN_EXPIRES_IN: int = TOKEN_EXPIRES_IN * 2\n    \"\"\"Refresh token lifetime in seconds. Defaults to TOKEN_EXPIRES_IN * 2 (48 hours).\"\"\"\n\n    ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT: bool = True\n    \"\"\"Issue refresh tokens during implicit grant dialog.\n\n    Note:\n        This flag can be used, when sets to `True`, to strictly meet the requirements\n        described in section 4.2 of the RFC 6749 regarding the issuance of refresh\n        tokens during grant type \"Implicit Grant\". In particular, as stated in section\n        4.2.2 of that RFC:\n\n        &gt; 4.2.2.  Access Token Response\n        &gt;\n        &gt; If the resource owner grants the access request, the authorization\n        &gt; server issues an access token and delivers it to the client by adding\n        &gt; the following parameters to the fragment component of the redirection\n        &gt; URI using the \"application/x-www-form-urlencoded\" format, per\n        &gt; Appendix B:\n        &gt;\n        &gt; [...]\n        &gt;\n        &gt; The authorization server MUST NOT issue a refresh token.\n\n        Reference links:\n\n        - [https://datatracker.ietf.org/doc/html/rfc6749#section-4.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2)\n        - [https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2)\n    \"\"\"\n\n    AUTHORIZATION_CODE_EXPIRES_IN: int = 5 * 60\n    \"\"\"Authorization code lifetime in seconds. Defaults to 5 minutes.\"\"\"\n\n    INSECURE_TRANSPORT: bool = False\n    \"\"\"Allow connections over SSL only.\n\n    Note:\n        When this option is disabled server will raise \"HTTP method is\n        not allowed\" error when attempting to access the server without\n        a valid SSL tunnel.\n    \"\"\"\n\n    ERROR_URI: str = \"\"\n    \"\"\"URI to redirect resource owner when server encounters error.\"\"\"\n\n    AVAILABLE: bool = True\n    \"\"\"Boolean indicating whether or not the server is available.\"\"\"\n\n    DEBUG: bool = False\n</code></pre>"},{"location":"sections/api/config/#aioauth.config.Settings.AUTHORIZATION_CODE_EXPIRES_IN","title":"<code>AUTHORIZATION_CODE_EXPIRES_IN = 5 * 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Authorization code lifetime in seconds. Defaults to 5 minutes.</p>"},{"location":"sections/api/config/#aioauth.config.Settings.AVAILABLE","title":"<code>AVAILABLE = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Boolean indicating whether or not the server is available.</p>"},{"location":"sections/api/config/#aioauth.config.Settings.ERROR_URI","title":"<code>ERROR_URI = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>URI to redirect resource owner when server encounters error.</p>"},{"location":"sections/api/config/#aioauth.config.Settings.INSECURE_TRANSPORT","title":"<code>INSECURE_TRANSPORT = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Allow connections over SSL only.</p> Note <p>When this option is disabled server will raise \"HTTP method is not allowed\" error when attempting to access the server without a valid SSL tunnel.</p>"},{"location":"sections/api/config/#aioauth.config.Settings.ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT","title":"<code>ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Issue refresh tokens during implicit grant dialog.</p> Note <p>This flag can be used, when sets to <code>True</code>, to strictly meet the requirements described in section 4.2 of the RFC 6749 regarding the issuance of refresh tokens during grant type \"Implicit Grant\". In particular, as stated in section 4.2.2 of that RFC:</p> <p>4.2.2.  Access Token Response</p> <p>If the resource owner grants the access request, the authorization server issues an access token and delivers it to the client by adding the following parameters to the fragment component of the redirection URI using the \"application/x-www-form-urlencoded\" format, per Appendix B:</p> <p>[...]</p> <p>The authorization server MUST NOT issue a refresh token.</p> <p>Reference links:</p> <ul> <li>https://datatracker.ietf.org/doc/html/rfc6749#section-4.2</li> <li>https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2</li> </ul>"},{"location":"sections/api/config/#aioauth.config.Settings.REFRESH_TOKEN_EXPIRES_IN","title":"<code>REFRESH_TOKEN_EXPIRES_IN = TOKEN_EXPIRES_IN * 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Refresh token lifetime in seconds. Defaults to TOKEN_EXPIRES_IN * 2 (48 hours).</p>"},{"location":"sections/api/config/#aioauth.config.Settings.TOKEN_EXPIRES_IN","title":"<code>TOKEN_EXPIRES_IN = 24 * 60 * 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Access token lifetime in seconds. Defaults to 24 hours.</p>"},{"location":"sections/api/constances/","title":"Constances","text":"<p>Constants that are used throughout the project. <pre><code>from aioauth import constances\n</code></pre></p>"},{"location":"sections/api/constances/#aioauth.constances.default_headers","title":"<code>default_headers = HTTPHeaderDict({'Content-Type': 'application/json', 'Cache-Control': 'no-store', 'Pragma': 'no-cache'})</code>  <code>module-attribute</code>","text":"<p>The authorization server must include the HTTP <code>Cache-Control</code> response header field, as per RFC2616, with a value of <code>no-store</code> in any response containing tokens, credentials, or other sensitive information, as well as the <code>Pragma</code> response header field, as per RFC2616, with a value of <code>no-cache</code>.</p>"},{"location":"sections/api/errors/","title":"Errors","text":"<p>Errors used throughout the project. <pre><code>from aioauth import errors\n</code></pre></p>"},{"location":"sections/api/errors/#aioauth.errors.AccessDeniedError","title":"<code>AccessDeniedError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The resource owner or authorization server denied the request</p> Source code in <code>aioauth/errors.py</code> <pre><code>class AccessDeniedError(OAuth2Error):\n    \"\"\"\n    The resource owner or authorization server denied the request\n    \"\"\"\n\n    error: ErrorType = \"access_denied\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InsecureTransportError","title":"<code>InsecureTransportError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>An exception will be thrown if the current request is not secure.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InsecureTransportError(OAuth2Error):\n    \"\"\"An exception will be thrown if the current request is not secure.\"\"\"\n\n    description = \"OAuth 2 MUST utilize https.\"\n    error: ErrorType = \"insecure_transport\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InvalidClientError","title":"<code>InvalidClientError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Client authentication failed (e.g. unknown client, no client authentication included, or unsupported authentication method). The authorization server may return an <code>HTTP 401</code> (Unauthorized) status code to indicate which HTTP authentication schemes are supported. If the client attempted to authenticate via the <code>Authorization</code> request header field, the authorization server must respond with an <code>HTTP 401</code> (Unauthorized) status code, and include the <code>WWW-Authenticate</code> response header field matching the authentication scheme used by the client.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InvalidClientError(OAuth2Error):\n    \"\"\"\n    Client authentication failed (e.g. unknown client, no client\n    authentication included, or unsupported authentication method).\n    The authorization server **may** return an `HTTP 401` (Unauthorized) status\n    code to indicate which HTTP authentication schemes are supported.\n    If the client attempted to authenticate via the ``Authorization`` request\n    header field, the authorization server **must** respond with an\n    `HTTP 401` (Unauthorized) status code, and include the `WWW-Authenticate`\n    response header field matching the authentication scheme used by the\n    client.\n    \"\"\"\n\n    error: ErrorType = \"invalid_client\"\n    status_code: HTTPStatus = HTTPStatus.UNAUTHORIZED\n\n    def __init__(\n        self,\n        request: Request,\n        description: Optional[str] = None,\n        headers: Optional[HTTPHeaderDict] = None,\n        state: Optional[str] = None,\n    ):\n        super().__init__(\n            request, description, headers or HTTPHeaderDict(default_headers), state\n        )\n\n        auth_values = [f\"error={self.error}\"]\n        if self.description:\n            auth_values.append(f\"error_description={self.description}\")\n        if self.error_uri:\n            auth_values.append(f\"error_uri={self.error_uri}\")\n        self.headers[\"WWW-Authenticate\"] = \"Basic \" + \", \".join(auth_values)\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InvalidGrantError","title":"<code>InvalidGrantError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The provided authorization grant (e.g. authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client.</p> <p>See RFC6749 section 5.2.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InvalidGrantError(OAuth2Error):\n    \"\"\"\n    The provided authorization grant (e.g. authorization code, resource\n    owner credentials) or refresh token is invalid, expired, revoked, does\n    not match the redirection URI used in the authorization request, or was\n    issued to another client.\n\n    See [RFC6749 section 5.2](https://tools.ietf.org/html/rfc6749#section-5.2).\n    \"\"\"\n\n    error: ErrorType = \"invalid_grant\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InvalidRedirectURIError","title":"<code>InvalidRedirectURIError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The requested redirect URI is missing or not allowed.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InvalidRedirectURIError(OAuth2Error):\n    \"\"\"\n    The requested redirect URI is missing or not allowed.\n    \"\"\"\n\n    error: ErrorType = \"invalid_request\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InvalidRequestError","title":"<code>InvalidRequestError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InvalidRequestError(OAuth2Error):\n    \"\"\"\n    The request is missing a required parameter, includes an invalid\n    parameter value, includes a parameter more than once, or is\n    otherwise malformed.\n    \"\"\"\n\n    error: ErrorType = \"invalid_request\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.InvalidScopeError","title":"<code>InvalidScopeError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The requested scope is invalid, unknown, or malformed, or exceeds the scope granted by the resource owner.</p> <p>See RFC6749 section 5.2.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class InvalidScopeError(OAuth2Error):\n    \"\"\"\n    The requested scope is invalid, unknown, or malformed, or\n    exceeds the scope granted by the resource owner.\n\n    See [RFC6749 section 5.2](https://tools.ietf.org/html/rfc6749#section-5.2).\n    \"\"\"\n\n    error: ErrorType = \"invalid_scope\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.MethodNotAllowedError","title":"<code>MethodNotAllowedError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The request is valid, but the method trying to be accessed is not available to the resource owner.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class MethodNotAllowedError(OAuth2Error):\n    \"\"\"\n    The request is valid, but the method trying to be accessed is not\n    available to the resource owner.\n    \"\"\"\n\n    description = \"HTTP method is not allowed.\"\n    status_code: HTTPStatus = HTTPStatus.METHOD_NOT_ALLOWED\n    error: ErrorType = \"method_is_not_allowed\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.MismatchingStateError","title":"<code>MismatchingStateError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>Unable to securely verify the integrity of the request and response.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class MismatchingStateError(OAuth2Error):\n    \"\"\"Unable to securely verify the integrity of the request and response.\"\"\"\n\n    description = \"CSRF Warning! State not equal in request and response.\"\n    error: ErrorType = \"mismatching_state\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.OAuth2Error","title":"<code>OAuth2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception that all other exceptions inherit from.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class OAuth2Error(Exception):\n    \"\"\"Base exception that all other exceptions inherit from.\"\"\"\n\n    error: ErrorType\n    description: str = \"\"\n    status_code: HTTPStatus = HTTPStatus.BAD_REQUEST\n    error_uri: str = \"\"\n    headers: HTTPHeaderDict = default_headers\n    state: str = \"\"\n\n    def __init__(\n        self,\n        request: Request,\n        description: Optional[str] = None,\n        headers: Optional[HTTPHeaderDict] = None,\n        state: Optional[str] = None,\n    ):\n        self.request = request\n\n        if description is not None:\n            self.description = description\n\n        if headers is not None:\n            self.headers = headers\n\n        if state is not None:\n            self.state = state\n\n        if request.settings.ERROR_URI:\n            self.error_uri = urljoin(request.settings.ERROR_URI, self.error)\n\n        super().__init__(f\"({self.error}) {self.description}\")\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authorization server encountered an unexpected condition that prevented it from fulfilling the request.  (This error code is needed because a <code>HTTP 500</code> (Internal Server Error) status code cannot be returned to the client via a HTTP redirect.)</p> Source code in <code>aioauth/errors.py</code> <pre><code>class ServerError(OAuth2Error):\n    \"\"\"\n    The authorization server encountered an unexpected condition that\n    prevented it from fulfilling the request.  (This error code is needed\n    because a ``HTTP 500`` (Internal Server Error) status code cannot be returned\n    to the client via a HTTP redirect.)\n    \"\"\"\n\n    error: ErrorType = \"server_error\"\n    status_code: HTTPStatus = HTTPStatus.BAD_REQUEST\n    description: str = \"Internal Server Error\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.TemporarilyUnavailableError","title":"<code>TemporarilyUnavailableError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server. (This error code is needed because a <code>HTTP 503</code> (Service Unavailable) status code cannot be returned to the client via a HTTP redirect.)</p> Source code in <code>aioauth/errors.py</code> <pre><code>class TemporarilyUnavailableError(OAuth2Error):\n    \"\"\"\n    The authorization server is currently unable to handle the request\n    due to a temporary overloading or maintenance of the server.\n    (This error code is needed because a ``HTTP 503`` (Service Unavailable)\n    status code cannot be returned to the client via a HTTP redirect.)\n    \"\"\"\n\n    error: ErrorType = \"temporarily_unavailable\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.UnauthorizedClientError","title":"<code>UnauthorizedClientError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authenticated client is not authorized to use this authorization grant type.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class UnauthorizedClientError(OAuth2Error):\n    \"\"\"\n    The authenticated client is not authorized to use this authorization\n    grant type.\n    \"\"\"\n\n    error: ErrorType = \"unauthorized_client\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.UnsupportedGrantTypeError","title":"<code>UnsupportedGrantTypeError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authorization grant type is not supported by the authorization server.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class UnsupportedGrantTypeError(OAuth2Error):\n    \"\"\"\n    The authorization grant type is not supported by the authorization\n    server.\n    \"\"\"\n\n    error: ErrorType = \"unsupported_grant_type\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.UnsupportedResponseTypeError","title":"<code>UnsupportedResponseTypeError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authorization server does not support obtaining an authorization code using this method.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class UnsupportedResponseTypeError(OAuth2Error):\n    \"\"\"\n    The authorization server does not support obtaining an authorization\n    code using this method.\n    \"\"\"\n\n    error: ErrorType = \"unsupported_response_type\"\n</code></pre>"},{"location":"sections/api/errors/#aioauth.errors.UnsupportedTokenTypeError","title":"<code>UnsupportedTokenTypeError</code>","text":"<p>               Bases: <code>OAuth2Error</code></p> <p>The authorization server does not support the revocation of the presented token type. That is, the client tried to revoke an access token on a server not supporting this feature.</p> Source code in <code>aioauth/errors.py</code> <pre><code>class UnsupportedTokenTypeError(OAuth2Error):\n    \"\"\"\n    The authorization server does not support the revocation of the presented\n    token type. That is, the client tried to revoke an access token on a server\n    not supporting this feature.\n    \"\"\"\n\n    error: ErrorType = \"unsupported_token_type\"\n</code></pre>"},{"location":"sections/api/grant_type/","title":"Grant Type","text":"<p>Different OAuth 2.0 grant types. <pre><code>from aioauth import grant_type\n</code></pre></p>"},{"location":"sections/api/grant_type/#aioauth.grant_type.AuthorizationCodeGrantType","title":"<code>AuthorizationCodeGrantType</code>","text":"<p>               Bases: <code>GrantTypeBase</code></p> <p>The Authorization Code grant type is used by confidential and public clients to exchange an authorization code for an access token. After the user returns to the client via the redirect URL, the application will get the authorization code from the URL and use it to request an access token. It is recommended that all clients use RFC 7636 Proof Key for Code Exchange extension with this flow as well to provide better security.</p> Note <p>Note that <code>aioauth</code> implements RFC 7636 out-of-the-box. See RFC 6749 section 1.3.1.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>class AuthorizationCodeGrantType(GrantTypeBase):\n    \"\"\"\n    The Authorization Code grant type is used by confidential and public\n    clients to exchange an authorization code for an access token. After\n    the user returns to the client via the redirect URL, the application\n    will get the authorization code from the URL and use it to request\n    an access token.\n    It is recommended that all clients use [RFC 7636](https://tools.ietf.org/html/rfc7636)\n    Proof Key for Code Exchange extension with this flow as well to\n    provide better security.\n\n    Note:\n        Note that `aioauth` implements RFC 7636 out-of-the-box.\n        See [RFC 6749 section 1.3.1](https://tools.ietf.org/html/rfc6749#section-1.3.1).\n    \"\"\"\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        client = await super().validate_request(request)\n\n        if not request.post.redirect_uri:\n            raise InvalidRedirectURIError(\n                request=request, description=\"Mismatching redirect URI.\"\n            )\n\n        if not client.check_redirect_uri(request.post.redirect_uri):\n            raise InvalidRedirectURIError(\n                request=request, description=\"Invalid redirect URI.\"\n            )\n\n        if not request.post.code:\n            raise InvalidRequestError(\n                request=request, description=\"Missing code parameter.\"\n            )\n\n        authorization_code = await self.storage.get_authorization_code(\n            request=request, client_id=client.client_id, code=request.post.code\n        )\n\n        if not authorization_code:\n            raise InvalidGrantError(request=request)\n\n        if (\n            authorization_code.code_challenge\n            and authorization_code.code_challenge_method\n        ):\n            if not request.post.code_verifier:\n                raise InvalidRequestError(\n                    request=request, description=\"Code verifier required.\"\n                )\n\n            is_valid_code_challenge = authorization_code.check_code_challenge(\n                request.post.code_verifier\n            )\n            if not is_valid_code_challenge:\n                raise MismatchingStateError(request=request)\n\n        if authorization_code.is_expired:\n            raise InvalidGrantError(request=request)\n\n        self.scope = authorization_code.scope\n        return client\n\n    async def create_token_response(\n        self, request: Request, client: Client\n    ) -&gt; TokenResponse:\n        token_response = await super().create_token_response(request, client)\n\n        if request.post.code is None:\n            raise\n\n        await self.storage.delete_authorization_code(\n            request=request,\n            client_id=client.client_id,\n            code=request.post.code,\n        )\n\n        return token_response\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.ClientCredentialsGrantType","title":"<code>ClientCredentialsGrantType</code>","text":"<p>               Bases: <code>GrantTypeBase</code></p> <p>The Client Credentials grant type is used by clients to obtain an access token outside of the context of a user. This is typically used by clients to access resources about themselves rather than to access a user's resources. See RFC 6749 section 4.4.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>class ClientCredentialsGrantType(GrantTypeBase):\n    \"\"\"\n    The Client Credentials grant type is used by clients to obtain an\n    access token outside of the context of a user. This is typically\n    used by clients to access resources about themselves rather than to\n    access a user's resources.\n    See [RFC 6749 section 4.4](https://tools.ietf.org/html/rfc6749#section-4.4).\n    \"\"\"\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        # client_credentials grant requires a client_secret\n        if self.client_secret is None:\n            raise InvalidClientError(request)\n\n        return await super().validate_request(request)\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.GrantTypeBase","title":"<code>GrantTypeBase</code>","text":"<p>Base grant type that all other grant types inherit from.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>class GrantTypeBase:\n    \"\"\"Base grant type that all other grant types inherit from.\"\"\"\n\n    def __init__(\n        self,\n        storage: BaseStorage,\n        client_id: str,\n        client_secret: Optional[str],\n    ):\n        self.storage = storage\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.scope: Optional[str] = None\n\n    async def create_token_response(\n        self, request: Request, client: Client\n    ) -&gt; TokenResponse:\n        \"\"\"Creates token response to reply to client.\"\"\"\n        if self.scope is None:\n            raise RuntimeError(\"validate_request() must be called first\")\n\n        token = await self.storage.create_token(\n            request=request,\n            client_id=client.client_id,\n            scope=self.scope,\n            access_token=generate_token(42),\n            refresh_token=generate_token(48),\n        )\n\n        return TokenResponse(\n            expires_in=token.expires_in,\n            refresh_token_expires_in=token.refresh_token_expires_in,\n            access_token=token.access_token,\n            refresh_token=token.refresh_token,\n            scope=token.scope,\n            token_type=token.token_type,\n        )\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        \"\"\"Validates the client request to ensure it is valid.\"\"\"\n        client = await self.storage.get_client(\n            request=request, client_id=self.client_id, client_secret=self.client_secret\n        )\n\n        if not client:\n            raise InvalidClientError(\n                request=request, description=\"Invalid client_id parameter value.\"\n            )\n\n        if not client.check_grant_type(request.post.grant_type):\n            raise UnauthorizedClientError(request=request)\n\n        if not client.check_scope(request.post.scope):\n            raise InvalidScopeError(request=request)\n\n        self.scope = request.post.scope\n        return client\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.GrantTypeBase.create_token_response","title":"<code>create_token_response(request, client)</code>  <code>async</code>","text":"<p>Creates token response to reply to client.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>async def create_token_response(\n    self, request: Request, client: Client\n) -&gt; TokenResponse:\n    \"\"\"Creates token response to reply to client.\"\"\"\n    if self.scope is None:\n        raise RuntimeError(\"validate_request() must be called first\")\n\n    token = await self.storage.create_token(\n        request=request,\n        client_id=client.client_id,\n        scope=self.scope,\n        access_token=generate_token(42),\n        refresh_token=generate_token(48),\n    )\n\n    return TokenResponse(\n        expires_in=token.expires_in,\n        refresh_token_expires_in=token.refresh_token_expires_in,\n        access_token=token.access_token,\n        refresh_token=token.refresh_token,\n        scope=token.scope,\n        token_type=token.token_type,\n    )\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.GrantTypeBase.validate_request","title":"<code>validate_request(request)</code>  <code>async</code>","text":"<p>Validates the client request to ensure it is valid.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>async def validate_request(self, request: Request) -&gt; Client:\n    \"\"\"Validates the client request to ensure it is valid.\"\"\"\n    client = await self.storage.get_client(\n        request=request, client_id=self.client_id, client_secret=self.client_secret\n    )\n\n    if not client:\n        raise InvalidClientError(\n            request=request, description=\"Invalid client_id parameter value.\"\n        )\n\n    if not client.check_grant_type(request.post.grant_type):\n        raise UnauthorizedClientError(request=request)\n\n    if not client.check_scope(request.post.scope):\n        raise InvalidScopeError(request=request)\n\n    self.scope = request.post.scope\n    return client\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.PasswordGrantType","title":"<code>PasswordGrantType</code>","text":"<p>               Bases: <code>GrantTypeBase</code></p> <p>The Password grant type is a way to exchange a user's credentials for an access token. Because the client application has to collect the user's password and send it to the authorization server, it is not recommended that this grant be used at all anymore. See RFC 6749 section 1.3.3. The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>class PasswordGrantType(GrantTypeBase):\n    \"\"\"\n    The Password grant type is a way to exchange a user's credentials\n    for an access token. Because the client application has to collect\n    the user's password and send it to the authorization server, it is\n    not recommended that this grant be used at all anymore.\n    See [RFC 6749 section 1.3.3](https://tools.ietf.org/html/rfc6749#section-1.3.3).\n    The latest [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4)\n    disallows the password grant entirely.\n    \"\"\"\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        client = await super().validate_request(request)\n\n        if not request.post.username or not request.post.password:\n            raise InvalidRequestError(\n                request=request, description=\"Invalid credentials given.\"\n            )\n\n        user = await self.storage.get_user(request)\n\n        if user is None:\n            raise InvalidRequestError(\n                request=request, description=\"Invalid credentials given.\"\n            )\n\n        return client\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.RefreshTokenGrantType","title":"<code>RefreshTokenGrantType</code>","text":"<p>               Bases: <code>GrantTypeBase</code></p> <p>The Refresh Token grant type is used by clients to exchange a refresh token for an access token when the access token has expired. This allows clients to continue to have a valid access token without further interaction with the user. See RFC 6749 section 1.5.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>class RefreshTokenGrantType(GrantTypeBase):\n    \"\"\"\n    The Refresh Token grant type is used by clients to exchange a\n    refresh token for an access token when the access token has expired.\n    This allows clients to continue to have a valid access token without\n    further interaction with the user.\n    See [RFC 6749 section 1.5](https://tools.ietf.org/html/rfc6749#section-1.5).\n    \"\"\"\n\n    async def create_token_response(\n        self, request: Request, client: Client\n    ) -&gt; TokenResponse:\n        \"\"\"Validate token request and create token response.\"\"\"\n        old_token = await self.storage.get_token(\n            request=request,\n            client_id=client.client_id,\n            refresh_token=request.post.refresh_token,\n            access_token=None,\n            token_type=\"refresh_token\",\n        )\n\n        if not old_token or old_token.revoked or old_token.refresh_token_expired:\n            raise InvalidGrantError(request=request)\n\n        # Revoke old token\n        await self.storage.revoke_token(\n            request=request,\n            client_id=client.client_id,\n            refresh_token=old_token.refresh_token,\n            token_type=\"refresh_token\",\n            access_token=None,\n        )\n\n        # new token should have at max the same scope as the old token\n        # (see https://www.oauth.com/oauth2-servers/making-authenticated-requests/refreshing-an-access-token/)\n        new_scope = old_token.scope\n        if request.post.scope:\n            # restrict requested tokens to requested scopes in the old token\n            new_scope = enforce_str(\n                list(\n                    set(enforce_list(old_token.scope))\n                    &amp; set(enforce_list(request.post.scope))\n                )\n            )\n\n        token = await self.storage.create_token(\n            request=request,\n            client_id=client.client_id,\n            scope=new_scope,\n            access_token=generate_token(42),\n            refresh_token=generate_token(48),\n        )\n\n        return TokenResponse(\n            expires_in=token.expires_in,\n            refresh_token_expires_in=token.refresh_token_expires_in,\n            access_token=token.access_token,\n            refresh_token=token.refresh_token,\n            scope=token.scope,\n            token_type=token.token_type,\n        )\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        client = await super().validate_request(request)\n\n        if not request.post.refresh_token:\n            raise InvalidRequestError(\n                request=request, description=\"Missing refresh token parameter.\"\n            )\n\n        return client\n</code></pre>"},{"location":"sections/api/grant_type/#aioauth.grant_type.RefreshTokenGrantType.create_token_response","title":"<code>create_token_response(request, client)</code>  <code>async</code>","text":"<p>Validate token request and create token response.</p> Source code in <code>aioauth/grant_type.py</code> <pre><code>async def create_token_response(\n    self, request: Request, client: Client\n) -&gt; TokenResponse:\n    \"\"\"Validate token request and create token response.\"\"\"\n    old_token = await self.storage.get_token(\n        request=request,\n        client_id=client.client_id,\n        refresh_token=request.post.refresh_token,\n        access_token=None,\n        token_type=\"refresh_token\",\n    )\n\n    if not old_token or old_token.revoked or old_token.refresh_token_expired:\n        raise InvalidGrantError(request=request)\n\n    # Revoke old token\n    await self.storage.revoke_token(\n        request=request,\n        client_id=client.client_id,\n        refresh_token=old_token.refresh_token,\n        token_type=\"refresh_token\",\n        access_token=None,\n    )\n\n    # new token should have at max the same scope as the old token\n    # (see https://www.oauth.com/oauth2-servers/making-authenticated-requests/refreshing-an-access-token/)\n    new_scope = old_token.scope\n    if request.post.scope:\n        # restrict requested tokens to requested scopes in the old token\n        new_scope = enforce_str(\n            list(\n                set(enforce_list(old_token.scope))\n                &amp; set(enforce_list(request.post.scope))\n            )\n        )\n\n    token = await self.storage.create_token(\n        request=request,\n        client_id=client.client_id,\n        scope=new_scope,\n        access_token=generate_token(42),\n        refresh_token=generate_token(48),\n    )\n\n    return TokenResponse(\n        expires_in=token.expires_in,\n        refresh_token_expires_in=token.refresh_token_expires_in,\n        access_token=token.access_token,\n        refresh_token=token.refresh_token,\n        scope=token.scope,\n        token_type=token.token_type,\n    )\n</code></pre>"},{"location":"sections/api/models/","title":"Models","text":"<p>Memory objects used throughout the project. <pre><code>from aioauth import models\n</code></pre></p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode","title":"<code>AuthorizationCode</code>  <code>dataclass</code>","text":"Source code in <code>aioauth/models.py</code> <pre><code>@dataclass\nclass AuthorizationCode:\n    code: str\n    \"\"\"\n    Authorization code that the client previously received from the\n    authorization server.\n    \"\"\"\n\n    client_id: str\n    \"\"\"\n    Public identifier for the client. It must also be unique across all\n    clients that the authorization server handles.\n    \"\"\"\n\n    redirect_uri: str\n    \"\"\"\n    After a user successfully authorizes an application, the\n    authorization server will redirect the user back to the application\n    with either an authorization code or access token in the URL.\n    Because the redirect URL will contain sensitive information, it is\n    critical that the service doesn\u2019t redirect the user to arbitrary\n    locations.\n    \"\"\"\n\n    response_type: str\n    \"\"\"A string containing the type of the response expected.\"\"\"\n\n    scope: str\n    \"\"\"\n    Scope is a mechanism that limit an application's access to a user's\n    account. An application can request one or more scopes, this\n    information is then presented to the user in the consent screen, and\n    the access token issued to the application will be limited to the\n    scopes granted.\n    \"\"\"\n\n    auth_time: int\n    \"\"\"\n    JSON Web Token Claim indicating the time when the authentication\n    occurred.\n    \"\"\"\n\n    expires_in: int\n    \"\"\"\n    Time delta in which authorization_code will expire.\n    \"\"\"\n\n    code_challenge: Optional[str] = None\n    \"\"\"\n    Only used when [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636),\n    Proof Key for Code Exchange, is used.\n    PKCE works by having the app generate a random value at the\n    beginning of the flow called a Code Verifier. The app hashes the\n    Code Verifier and the result is called the Code Challenge. The app\n    then kicks off the flow in the normal way, except that it includes\n    the Code Challenge in the query string for the request to the\n    Authorization Server.\n    \"\"\"\n\n    code_challenge_method: Optional[CodeChallengeMethod] = None\n    \"\"\"\n    Only used when [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636&gt;),\n    Proof Key for Code Exchange, is used.\n    Method used to transform the code verifier into the code challenge.\n    \"\"\"\n\n    nonce: Optional[str] = None\n    \"\"\"\n    Only used when [RFC 7636](https://datatracker.ietf.org/doc/html/rfc7636),\n    Proof Key for Code Exchange, is used.\n    Random piece of data.\n    \"\"\"\n\n    def check_code_challenge(self, code_verifier: str) -&gt; bool:\n        is_valid_code_challenge = False\n\n        if self.code_challenge_method == \"plain\":\n            # If the \"code_challenge_method\" was \"plain\", they are compared directly\n            # Use constant-time comparison to prevent timing attacks\n            is_valid_code_challenge = secrets.compare_digest(\n                code_verifier, self.code_challenge or \"\"\n            )\n\n        if self.code_challenge_method == \"S256\":\n            # base64url(sha256(ascii(code_verifier))) == code_challenge\n            # Use constant-time comparison to prevent timing attacks\n            computed_challenge = create_s256_code_challenge(code_verifier)\n            is_valid_code_challenge = secrets.compare_digest(\n                computed_challenge, self.code_challenge or \"\"\n            )\n\n        return is_valid_code_challenge\n\n    @property\n    def is_expired(self) -&gt; bool:\n        \"\"\"Checks if the authorization_code has expired.\"\"\"\n        return self.auth_time + self.expires_in &lt; time.time()\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.auth_time","title":"<code>auth_time</code>  <code>instance-attribute</code>","text":"<p>JSON Web Token Claim indicating the time when the authentication occurred.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.client_id","title":"<code>client_id</code>  <code>instance-attribute</code>","text":"<p>Public identifier for the client. It must also be unique across all clients that the authorization server handles.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.code","title":"<code>code</code>  <code>instance-attribute</code>","text":"<p>Authorization code that the client previously received from the authorization server.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.code_challenge","title":"<code>code_challenge = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Only used when RFC 7636, Proof Key for Code Exchange, is used. PKCE works by having the app generate a random value at the beginning of the flow called a Code Verifier. The app hashes the Code Verifier and the result is called the Code Challenge. The app then kicks off the flow in the normal way, except that it includes the Code Challenge in the query string for the request to the Authorization Server.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.code_challenge_method","title":"<code>code_challenge_method = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Only used when RFC 7636, Proof Key for Code Exchange, is used. Method used to transform the code verifier into the code challenge.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.expires_in","title":"<code>expires_in</code>  <code>instance-attribute</code>","text":"<p>Time delta in which authorization_code will expire.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.is_expired","title":"<code>is_expired</code>  <code>property</code>","text":"<p>Checks if the authorization_code has expired.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.nonce","title":"<code>nonce = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Only used when RFC 7636, Proof Key for Code Exchange, is used. Random piece of data.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.redirect_uri","title":"<code>redirect_uri</code>  <code>instance-attribute</code>","text":"<p>After a user successfully authorizes an application, the authorization server will redirect the user back to the application with either an authorization code or access token in the URL. Because the redirect URL will contain sensitive information, it is critical that the service doesn\u2019t redirect the user to arbitrary locations.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.response_type","title":"<code>response_type</code>  <code>instance-attribute</code>","text":"<p>A string containing the type of the response expected.</p>"},{"location":"sections/api/models/#aioauth.models.AuthorizationCode.scope","title":"<code>scope</code>  <code>instance-attribute</code>","text":"<p>Scope is a mechanism that limit an application's access to a user's account. An application can request one or more scopes, this information is then presented to the user in the consent screen, and the access token issued to the application will be limited to the scopes granted.</p>"},{"location":"sections/api/models/#aioauth.models.Client","title":"<code>Client</code>  <code>dataclass</code>","text":"<p>OAuth2.0 client model object.</p> Source code in <code>aioauth/models.py</code> <pre><code>@dataclass\nclass Client:\n    \"\"\"OAuth2.0 client model object.\"\"\"\n\n    client_id: str\n    \"\"\"\n    Public identifier for the client. It must also be unique across all\n    clients that the authorization server handles.\n    \"\"\"\n\n    client_secret: str\n    \"\"\"\n    Client secret is a secret known only to the client and the\n    authorization server. Used for secure communication between the\n    client and authorization server.\n    \"\"\"\n\n    grant_types: List[GrantType]\n    \"\"\"\n    The method(s) in which an application gets an access token from the\n    provider. Each grant type is optimized for a particular use case,\n    whether that\u2019s a web app, a native app, a device without the ability\n    to launch a web browser, or server-to-server applications.\n    \"\"\"\n\n    response_types: List[ResponseType]\n    \"\"\"A list containing the types of the response expected.\"\"\"\n\n    redirect_uris: List[str]\n    \"\"\"\n    After a user successfully authorizes an application, the\n    authorization server will redirect the user back to the application\n    with either an authorization code or access token in the URL.\n    Because the redirect URL will contain sensitive information, it is\n    critical that the service doesn\u2019t redirect the user to arbitrary\n    locations.\n    \"\"\"\n\n    scope: str = \"\"\n    \"\"\"\n    Scope is a mechanism that limit an application's access to a user's\n    account. An application can request one or more scopes, this\n    information is then presented to the user in the consent screen, and\n    the access token issued to the application will be limited to the\n    scopes granted.\n    \"\"\"\n\n    def check_redirect_uri(self, redirect_uri) -&gt; bool:\n        \"\"\"\n        Verifies passed `redirect_uri` is part of the Clients's\n        `redirect_uris` list.\n        \"\"\"\n        return redirect_uri in self.redirect_uris\n\n    def check_grant_type(self, grant_type: Optional[GrantType]) -&gt; bool:\n        \"\"\"\n        Verifies passed `grant_type` is part of the client's\n        `grant_types` list.\n        \"\"\"\n        return grant_type in self.grant_types if grant_type else False\n\n    def check_response_type(\n        self, response_type: Optional[Union[ResponseType, str]]\n    ) -&gt; bool:\n        \"\"\"\n        Verifies passed `response_type` is part of the client's\n        `response_types` list.\n        \"\"\"\n        return not (set(enforce_list(response_type)) - set(self.response_types))\n\n    def get_allowed_scope(self, scope: str) -&gt; str:\n        \"\"\"\n        Returns the allowed `scope` given the passed `scope`.\n\n        Note:\n            Note that the passed `scope` may contain multiple scopes\n            seperated by a space character.\n        \"\"\"\n        if not scope:\n            return \"\"\n        allowed = set(self.scope.split())\n        scopes = enforce_list(scope)\n        return enforce_str([s for s in scopes if s in allowed])\n\n    def check_scope(self, scope: str) -&gt; bool:\n        allowed_scope = self.get_allowed_scope(scope)\n        return not (set(enforce_list(scope)) - set(enforce_list(allowed_scope)))\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Client.client_id","title":"<code>client_id</code>  <code>instance-attribute</code>","text":"<p>Public identifier for the client. It must also be unique across all clients that the authorization server handles.</p>"},{"location":"sections/api/models/#aioauth.models.Client.client_secret","title":"<code>client_secret</code>  <code>instance-attribute</code>","text":"<p>Client secret is a secret known only to the client and the authorization server. Used for secure communication between the client and authorization server.</p>"},{"location":"sections/api/models/#aioauth.models.Client.grant_types","title":"<code>grant_types</code>  <code>instance-attribute</code>","text":"<p>The method(s) in which an application gets an access token from the provider. Each grant type is optimized for a particular use case, whether that\u2019s a web app, a native app, a device without the ability to launch a web browser, or server-to-server applications.</p>"},{"location":"sections/api/models/#aioauth.models.Client.redirect_uris","title":"<code>redirect_uris</code>  <code>instance-attribute</code>","text":"<p>After a user successfully authorizes an application, the authorization server will redirect the user back to the application with either an authorization code or access token in the URL. Because the redirect URL will contain sensitive information, it is critical that the service doesn\u2019t redirect the user to arbitrary locations.</p>"},{"location":"sections/api/models/#aioauth.models.Client.response_types","title":"<code>response_types</code>  <code>instance-attribute</code>","text":"<p>A list containing the types of the response expected.</p>"},{"location":"sections/api/models/#aioauth.models.Client.scope","title":"<code>scope = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Scope is a mechanism that limit an application's access to a user's account. An application can request one or more scopes, this information is then presented to the user in the consent screen, and the access token issued to the application will be limited to the scopes granted.</p>"},{"location":"sections/api/models/#aioauth.models.Client.check_grant_type","title":"<code>check_grant_type(grant_type)</code>","text":"<p>Verifies passed <code>grant_type</code> is part of the client's <code>grant_types</code> list.</p> Source code in <code>aioauth/models.py</code> <pre><code>def check_grant_type(self, grant_type: Optional[GrantType]) -&gt; bool:\n    \"\"\"\n    Verifies passed `grant_type` is part of the client's\n    `grant_types` list.\n    \"\"\"\n    return grant_type in self.grant_types if grant_type else False\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Client.check_redirect_uri","title":"<code>check_redirect_uri(redirect_uri)</code>","text":"<p>Verifies passed <code>redirect_uri</code> is part of the Clients's <code>redirect_uris</code> list.</p> Source code in <code>aioauth/models.py</code> <pre><code>def check_redirect_uri(self, redirect_uri) -&gt; bool:\n    \"\"\"\n    Verifies passed `redirect_uri` is part of the Clients's\n    `redirect_uris` list.\n    \"\"\"\n    return redirect_uri in self.redirect_uris\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Client.check_response_type","title":"<code>check_response_type(response_type)</code>","text":"<p>Verifies passed <code>response_type</code> is part of the client's <code>response_types</code> list.</p> Source code in <code>aioauth/models.py</code> <pre><code>def check_response_type(\n    self, response_type: Optional[Union[ResponseType, str]]\n) -&gt; bool:\n    \"\"\"\n    Verifies passed `response_type` is part of the client's\n    `response_types` list.\n    \"\"\"\n    return not (set(enforce_list(response_type)) - set(self.response_types))\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Client.get_allowed_scope","title":"<code>get_allowed_scope(scope)</code>","text":"<p>Returns the allowed <code>scope</code> given the passed <code>scope</code>.</p> Note <p>Note that the passed <code>scope</code> may contain multiple scopes seperated by a space character.</p> Source code in <code>aioauth/models.py</code> <pre><code>def get_allowed_scope(self, scope: str) -&gt; str:\n    \"\"\"\n    Returns the allowed `scope` given the passed `scope`.\n\n    Note:\n        Note that the passed `scope` may contain multiple scopes\n        seperated by a space character.\n    \"\"\"\n    if not scope:\n        return \"\"\n    allowed = set(self.scope.split())\n    scopes = enforce_list(scope)\n    return enforce_str([s for s in scopes if s in allowed])\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"Source code in <code>aioauth/models.py</code> <pre><code>@dataclass\nclass Token:\n    access_token: str\n    \"\"\"\n    Token that clients use to make API requests on behalf of the\n    resource owner.\n    \"\"\"\n\n    refresh_token: Optional[str]\n    \"\"\"\n    Token used by clients to exchange a refresh token for an access\n    token when the access token has expired.\n    \"\"\"\n\n    scope: str\n    \"\"\"\n    Scope is a mechanism that limit an application's access to a user's\n    account. An application can request one or more scopes, this\n    information is then presented to the user in the consent screen, and\n    the access token issued to the application will be limited to the\n    scopes granted.\n    \"\"\"\n\n    issued_at: int\n    \"\"\"\n    Time date in which token was issued at.\n    \"\"\"\n\n    expires_in: int\n    \"\"\"\n    Time delta in which token will expire.\n    \"\"\"\n\n    refresh_token_expires_in: int\n    \"\"\"\n    Time delta in which refresh token will expire.\n    \"\"\"\n\n    client_id: str\n    \"\"\"\n    Public identifier for the client. It must also be unique across all\n    clients that the authorization server handles.\n    \"\"\"\n\n    token_type: TokenType = \"Bearer\"\n    \"\"\"\n    Type of token expected.\n    \"\"\"\n\n    revoked: bool = False\n    \"\"\"\n    Flag that indicates whether or not the token has been revoked.\n    \"\"\"\n\n    @property\n    def is_expired(self) -&gt; bool:\n        \"\"\"Checks if the token has expired.\"\"\"\n        return (self.issued_at + self.expires_in) &lt; time.time()\n\n    @property\n    def refresh_token_expired(self) -&gt; bool:\n        \"\"\"Checks if refresh token has expired.\"\"\"\n        return (self.issued_at + self.refresh_token_expires_in) &lt; time.time()\n</code></pre>"},{"location":"sections/api/models/#aioauth.models.Token.access_token","title":"<code>access_token</code>  <code>instance-attribute</code>","text":"<p>Token that clients use to make API requests on behalf of the resource owner.</p>"},{"location":"sections/api/models/#aioauth.models.Token.client_id","title":"<code>client_id</code>  <code>instance-attribute</code>","text":"<p>Public identifier for the client. It must also be unique across all clients that the authorization server handles.</p>"},{"location":"sections/api/models/#aioauth.models.Token.expires_in","title":"<code>expires_in</code>  <code>instance-attribute</code>","text":"<p>Time delta in which token will expire.</p>"},{"location":"sections/api/models/#aioauth.models.Token.is_expired","title":"<code>is_expired</code>  <code>property</code>","text":"<p>Checks if the token has expired.</p>"},{"location":"sections/api/models/#aioauth.models.Token.issued_at","title":"<code>issued_at</code>  <code>instance-attribute</code>","text":"<p>Time date in which token was issued at.</p>"},{"location":"sections/api/models/#aioauth.models.Token.refresh_token","title":"<code>refresh_token</code>  <code>instance-attribute</code>","text":"<p>Token used by clients to exchange a refresh token for an access token when the access token has expired.</p>"},{"location":"sections/api/models/#aioauth.models.Token.refresh_token_expired","title":"<code>refresh_token_expired</code>  <code>property</code>","text":"<p>Checks if refresh token has expired.</p>"},{"location":"sections/api/models/#aioauth.models.Token.refresh_token_expires_in","title":"<code>refresh_token_expires_in</code>  <code>instance-attribute</code>","text":"<p>Time delta in which refresh token will expire.</p>"},{"location":"sections/api/models/#aioauth.models.Token.revoked","title":"<code>revoked = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flag that indicates whether or not the token has been revoked.</p>"},{"location":"sections/api/models/#aioauth.models.Token.scope","title":"<code>scope</code>  <code>instance-attribute</code>","text":"<p>Scope is a mechanism that limit an application's access to a user's account. An application can request one or more scopes, this information is then presented to the user in the consent screen, and the access token issued to the application will be limited to the scopes granted.</p>"},{"location":"sections/api/models/#aioauth.models.Token.token_type","title":"<code>token_type = 'Bearer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of token expected.</p>"},{"location":"sections/api/requests/","title":"Requests","text":"<p>Request objects used throughout the project. <pre><code>from aioauth import requests\n</code></pre></p>"},{"location":"sections/api/requests/#aioauth.requests.Post","title":"<code>Post</code>  <code>dataclass</code>","text":"<p>Object that contains a client's post request portion of a request. Read more on post requests here.</p> Source code in <code>aioauth/requests.py</code> <pre><code>@dataclass\nclass Post:\n    \"\"\"\n    Object that contains a client's post request portion of a request.\n    Read more on post requests [here](https://en.wikipedia.org/wiki/POST_(HTTP)).\n    \"\"\"\n\n    grant_type: Optional[GrantType] = None\n    client_id: Optional[str] = None\n    client_secret: Optional[str] = None\n    redirect_uri: Optional[str] = None\n    scope: str = \"\"\n    username: Optional[str] = None\n    password: Optional[str] = None\n    refresh_token: Optional[str] = None\n    code: Optional[str] = None\n    token: Optional[str] = None\n    token_type_hint: Optional[TokenType] = None\n    code_verifier: Optional[str] = None\n</code></pre>"},{"location":"sections/api/requests/#aioauth.requests.Query","title":"<code>Query</code>  <code>dataclass</code>","text":"<p>Object that contains a client's query string portion of a request. Read more on query strings here.</p> Source code in <code>aioauth/requests.py</code> <pre><code>@dataclass\nclass Query:\n    \"\"\"\n    Object that contains a client's query string portion of a request.\n    Read more on query strings [here](https://en.wikipedia.org/wiki/Query_string).\n    \"\"\"\n\n    client_id: Optional[str] = None\n    redirect_uri: str = \"\"\n    response_type: Optional[str] = None\n    state: str = \"\"\n    scope: str = \"\"\n    nonce: Optional[str] = None\n    code_challenge_method: Optional[CodeChallengeMethod] = None\n    code_challenge: Optional[str] = None\n    response_mode: Optional[ResponseMode] = None\n</code></pre>"},{"location":"sections/api/requests/#aioauth.requests.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>Object that contains a client's complete request.</p> Source code in <code>aioauth/requests.py</code> <pre><code>@dataclass\nclass Request:\n    \"\"\"Object that contains a client's complete request.\"\"\"\n\n    method: RequestMethod\n    query: Query = field(default_factory=Query)\n    post: Post = field(default_factory=Post)\n    headers: HTTPHeaderDict = field(default_factory=HTTPHeaderDict)\n    url: str = \"\"\n    settings: Settings = field(default_factory=Settings)\n    extra: dict = field(default_factory=dict)\n</code></pre>"},{"location":"sections/api/response_type/","title":"Response Type","text":"<p>Response objects used throughout the project. <pre><code>from aioauth import responses\n</code></pre></p>"},{"location":"sections/api/response_type/#aioauth.response_type.ResponseTypeAuthorizationCode","title":"<code>ResponseTypeAuthorizationCode</code>","text":"<p>               Bases: <code>ResponseTypeBase</code></p> <p>Response type that contains an authorization code.</p> Source code in <code>aioauth/response_type.py</code> <pre><code>class ResponseTypeAuthorizationCode(ResponseTypeBase):\n    \"\"\"Response type that contains an authorization code.\"\"\"\n\n    async def create_authorization_response(\n        self, request: Request, client: Client\n    ) -&gt; AuthorizationCodeResponse:\n        assert request.query.response_type, (\n            \"`response_type` cannot be an empty string or `None`. \"\n            \"Please make sure you call `validate_request` before calling this method.\"\n        )\n        authorization_code = await self.storage.create_authorization_code(\n            client_id=client.client_id,\n            code=generate_token(42),\n            code_challenge=request.query.code_challenge,\n            code_challenge_method=request.query.code_challenge_method,\n            nonce=request.query.nonce,\n            redirect_uri=request.query.redirect_uri,\n            request=request,\n            response_type=request.query.response_type,\n            scope=request.query.scope,\n        )\n        return AuthorizationCodeResponse(\n            code=authorization_code.code,\n            scope=authorization_code.scope,\n        )\n</code></pre>"},{"location":"sections/api/response_type/#aioauth.response_type.ResponseTypeBase","title":"<code>ResponseTypeBase</code>","text":"<p>Base response type that all other exceptions inherit from.</p> Source code in <code>aioauth/response_type.py</code> <pre><code>class ResponseTypeBase:\n    \"\"\"Base response type that all other exceptions inherit from.\"\"\"\n\n    def __init__(self, storage: BaseStorage):\n        self.storage = storage\n\n    async def validate_request(self, request: Request) -&gt; Client:\n        state = request.query.state\n\n        code_challenge_methods: Tuple[CodeChallengeMethod, ...] = get_args(\n            CodeChallengeMethod\n        )\n\n        if not request.query.client_id:\n            raise InvalidClientError(\n                request=request, description=\"Missing client_id parameter.\", state=state\n            )\n\n        client = await self.storage.get_client(\n            request=request, client_id=request.query.client_id\n        )\n\n        if not client:\n            raise InvalidClientError(\n                request=request,\n                description=\"Invalid client_id parameter value.\",\n                state=state,\n            )\n\n        if not request.query.redirect_uri:\n            raise InvalidRedirectURIError(\n                request=request, description=\"Mismatching redirect URI.\", state=state\n            )\n\n        if not client.check_redirect_uri(request.query.redirect_uri):\n            raise InvalidRedirectURIError(\n                request=request, description=\"Invalid redirect URI.\", state=state\n            )\n\n        if request.query.code_challenge_method:\n            if request.query.code_challenge_method not in code_challenge_methods:\n                raise InvalidRequestError(\n                    request=request,\n                    description=\"Transform algorithm not supported.\",\n                    state=state,\n                )\n\n            if not request.query.code_challenge:\n                raise InvalidRequestError(\n                    request=request, description=\"Code challenge required.\", state=state\n                )\n\n        if not client.check_response_type(request.query.response_type):\n            raise UnsupportedResponseTypeError(request=request, state=state)\n\n        if not client.check_scope(request.query.scope):\n            raise InvalidScopeError(request=request, state=state)\n\n        return client\n</code></pre>"},{"location":"sections/api/response_type/#aioauth.response_type.ResponseTypeToken","title":"<code>ResponseTypeToken</code>","text":"<p>               Bases: <code>ResponseTypeBase</code></p> <p>Response type that contains a token.</p> Source code in <code>aioauth/response_type.py</code> <pre><code>class ResponseTypeToken(ResponseTypeBase):\n    \"\"\"Response type that contains a token.\"\"\"\n\n    async def create_authorization_response(\n        self, request: Request, client: Client\n    ) -&gt; TokenResponse:\n        token = await self.storage.create_token(\n            request=request,\n            client_id=client.client_id,\n            scope=request.query.scope,\n            access_token=generate_token(42),\n            refresh_token=(\n                generate_token(48)\n                if request.settings.ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT\n                else None\n            ),\n        )\n        if not request.settings.ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT:\n            return TokenResponse(\n                expires_in=token.expires_in,\n                access_token=token.access_token,\n                scope=token.scope,\n                token_type=token.token_type,\n            )\n        return TokenResponse(\n            expires_in=token.expires_in,\n            refresh_token_expires_in=token.refresh_token_expires_in,\n            access_token=token.access_token,\n            refresh_token=token.refresh_token,\n            scope=token.scope,\n            token_type=token.token_type,\n        )\n</code></pre>"},{"location":"sections/api/responses/","title":"Responses","text":"<p>Response objects used throughout the project. <pre><code>from aioauth import responses\n</code></pre></p>"},{"location":"sections/api/responses/#aioauth.responses.AuthorizationCodeResponse","title":"<code>AuthorizationCodeResponse</code>  <code>dataclass</code>","text":"<p>Response for <code>authorization_code</code>.</p> <p>Used by <code>aioauth.response_type.ResponseTypeAuthorizationCode</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass AuthorizationCodeResponse:\n    \"\"\"Response for `authorization_code`.\n\n    Used by `aioauth.response_type.ResponseTypeAuthorizationCode`.\n    \"\"\"\n\n    code: str\n    scope: str\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.ErrorResponse","title":"<code>ErrorResponse</code>  <code>dataclass</code>","text":"<p>Response for errors.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass ErrorResponse:\n    \"\"\"Response for errors.\"\"\"\n\n    error: ErrorType\n    description: str\n    error_uri: str = \"\"\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.IdTokenResponse","title":"<code>IdTokenResponse</code>  <code>dataclass</code>","text":"<p>Response for OpenID id_token.</p> <p>Used by <code>aioauth.response_type.ResponseResponseTypeIdTokenTypeToken</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass IdTokenResponse:\n    \"\"\"Response for OpenID id_token.\n\n    Used by `aioauth.response_type.ResponseResponseTypeIdTokenTypeToken`.\n    \"\"\"\n\n    id_token: str\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.NoneResponse","title":"<code>NoneResponse</code>  <code>dataclass</code>","text":"<p>Response for <code>aioauth.response_type.ResponseTypeNone</code>.</p> <p>See: OAuth v2 multiple response types,</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass NoneResponse:\n    \"\"\"Response for `aioauth.response_type.ResponseTypeNone`.\n\n    See: [OAuth v2 multiple response types](https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#none),\n    \"\"\"\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.Response","title":"<code>Response</code>  <code>dataclass</code>","text":"<p>General response class.</p> <p>Used by <code>aioauth.server.AuthorizationServer</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass Response:\n    \"\"\"General response class.\n\n    Used by `aioauth.server.AuthorizationServer`.\n    \"\"\"\n\n    content: Dict = field(default_factory=dict)\n    status_code: HTTPStatus = HTTPStatus.OK\n    headers: HTTPHeaderDict = field(\n        default_factory=lambda: default_headers\n    )  # pragma: no cover\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.TokenActiveIntrospectionResponse","title":"<code>TokenActiveIntrospectionResponse</code>  <code>dataclass</code>","text":"<p>Response for a valid access token.</p> <p>Used by <code>aioauth.server.AuthorizationServer.create_token_introspection_response</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass TokenActiveIntrospectionResponse:\n    \"\"\"Response for a valid access token.\n\n    Used by `aioauth.server.AuthorizationServer.create_token_introspection_response`.\n    \"\"\"\n\n    scope: str\n    client_id: str\n    token_type: TokenType\n    expires_in: int\n    active: bool = True\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.TokenInactiveIntrospectionResponse","title":"<code>TokenInactiveIntrospectionResponse</code>  <code>dataclass</code>","text":"<p>For an invalid, revoked or expired token.</p> <p>Used by <code>aioauth.server.AuthorizationServer.create_token_introspection_response</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass TokenInactiveIntrospectionResponse:\n    \"\"\"For an invalid, revoked or expired token.\n\n    Used by `aioauth.server.AuthorizationServer.create_token_introspection_response`.\n    \"\"\"\n\n    active: bool = False\n</code></pre>"},{"location":"sections/api/responses/#aioauth.responses.TokenResponse","title":"<code>TokenResponse</code>  <code>dataclass</code>","text":"<p>Response for valid token.</p> <p>Used by <code>aioauth.response_type.ResponseTypeToken</code>.</p> Source code in <code>aioauth/responses.py</code> <pre><code>@dataclass\nclass TokenResponse:\n    \"\"\"Response for valid token.\n\n    Used by `aioauth.response_type.ResponseTypeToken`.\n    \"\"\"\n\n    expires_in: int\n    access_token: str\n    scope: str\n    refresh_token_expires_in: Optional[int] = None\n    refresh_token: Optional[str] = None\n    token_type: str = \"Bearer\"\n</code></pre>"},{"location":"sections/api/server/","title":"Server","text":"<p>Memory object and interface used to initialize an OAuth2.0 server instance.</p> Warning <p>Note that <code>aioauth.server.AuthorizationServer</code> is not depedent on any server framework, nor serves at any specific endpoint. Instead, it is used to create an interface that can be used in conjunction with a server framework like <code>FastAPI</code> or <code>aiohttp</code> to create a fully functional OAuth 2.0 server. Check out the Examples portion of the documentation to understand how it can be leveraged in your own project.</p> <pre><code>from aioauth import server\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer","title":"<code>AuthorizationServer</code>","text":"<p>Interface for initializing an OAuth 2.0 server.</p> Source code in <code>aioauth/server.py</code> <pre><code>class AuthorizationServer:\n    \"\"\"Interface for initializing an OAuth 2.0 server.\"\"\"\n\n    response_types: Dict[\n        ResponseType,\n        Union[\n            type[ResponseTypeToken],\n            type[ResponseTypeAuthorizationCode],\n            type[ResponseTypeNone],\n            type[ResponseTypeIdToken],\n        ],\n    ] = {\n        \"token\": ResponseTypeToken,\n        \"code\": ResponseTypeAuthorizationCode,\n        \"none\": ResponseTypeNone,\n        \"id_token\": ResponseTypeIdToken,\n    }\n    grant_types: Dict[\n        GrantType,\n        Union[\n            type[AuthorizationCodeGrantType],\n            type[ClientCredentialsGrantType],\n            type[PasswordGrantType],\n            type[RefreshTokenGrantType],\n        ],\n    ] = {\n        \"authorization_code\": AuthorizationCodeGrantType,\n        \"client_credentials\": ClientCredentialsGrantType,\n        \"password\": PasswordGrantType,\n        \"refresh_token\": RefreshTokenGrantType,\n    }\n\n    def __init__(\n        self,\n        storage: BaseStorage,\n        response_types: Optional[Dict] = None,\n        grant_types: Optional[Dict] = None,\n    ):\n        self.storage = storage\n\n        if response_types is not None:\n            self.response_types = response_types\n\n        if grant_types is not None:\n            self.grant_types = grant_types\n\n    def is_secure_transport(self, request: Request) -&gt; bool:\n        \"\"\"\n        Verifies the request was sent via a protected SSL tunnel.\n\n        Note:\n            This method checks if the request URL contains\n            ``https://`` at the start of it. For production use,\n            additional SSL certificate validation should be implemented\n            at the web server level (nginx, Apache) or load balancer.\n\n        Args:\n            request: `aioauth.requests.Request` object.\n\n        Returns:\n            Flag representing whether or not the transport is secure.\n        \"\"\"\n        if request.settings.INSECURE_TRANSPORT:\n            return True\n\n        # Check for HTTPS scheme\n        if not request.url.lower().startswith(\"https://\"):\n            return False\n\n        # Additional check for X-Forwarded-Proto header (for load balancers/proxies)\n        forwarded_proto = request.headers.get(\"X-Forwarded-Proto\", \"\").lower()\n        if forwarded_proto and forwarded_proto != \"https\":\n            return False\n\n        return True\n\n    def validate_request(self, request: Request, allowed_methods: List[RequestMethod]):\n        if not request.settings.AVAILABLE:\n            raise TemporarilyUnavailableError(request=request)\n\n        if not self.is_secure_transport(request):\n            raise InsecureTransportError(request=request)\n\n        if request.method not in allowed_methods:\n            headers = HTTPHeaderDict(\n                {**default_headers, \"allow\": \", \".join(allowed_methods)}\n            )\n            raise MethodNotAllowedError(request=request, headers=headers)\n\n    @catch_errors_and_unavailability()\n    async def create_token_introspection_response(self, request: Request) -&gt; Response:\n        \"\"\"\n        Returns a response object with introspection of the passed token.\n        For more information see [RFC7662 section 2.1](https://tools.ietf.org/html/rfc7662#section-2.1).\n\n        Note:\n            The API endpoint that leverages this function is usually\n            `/introspect`.\n\n        Example:\n            Below is an example utilizing FastAPI as the server framework.\n\n        ```python\n        from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n        @app.get(\"/token/introspect\")\n        async def introspect(request: fastapi.Request) -&gt; fastapi.Response:\n            # Converts a fastapi.Request to an aioauth.Request.\n            oauth2_request: aioauth.Request = await to_oauth2_request(request)\n            # Creates the response via this function call.\n            oauth2_response: aioauth.Response = await server.create_token_introspection_response(oauth2_request)\n            # Converts an aioauth.Response to a fastapi.Response.\n            response: fastapi.Response = await to_fastapi_response(oauth2_response)\n            return response\n        ```\n\n        Args:\n            request: An `aioauth.requests.Request` object.\n\n        Returns:\n            response: An `aioauth.responses.Response` object.\n        \"\"\"\n        self.validate_request(request, [\"POST\"])\n        client_id, client_secret = self.get_client_credentials(\n            request, secret_required=True\n        )\n\n        client = await self.storage.get_client(\n            request=request, client_id=client_id, client_secret=client_secret\n        )\n\n        if not client:\n            raise InvalidClientError(request)\n\n        token_types: Tuple[TokenType, ...] = get_args(TokenType)\n        token_type: TokenType = \"refresh_token\"\n\n        access_token = None\n        refresh_token = request.post.token\n\n        if request.post.token_type_hint in token_types:\n            token_type = request.post.token_type_hint\n\n        if token_type == \"access_token\":  # nosec\n            access_token = request.post.token\n            refresh_token = None\n\n        token = await self.storage.get_token(\n            request=request,\n            client_id=client_id,\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=token_type,\n        )\n\n        token_response: Union[\n            TokenInactiveIntrospectionResponse, TokenActiveIntrospectionResponse\n        ]\n\n        if token and not token.is_expired and not token.revoked:\n            token_response = TokenActiveIntrospectionResponse(\n                scope=token.scope,\n                client_id=token.client_id,\n                expires_in=token.expires_in,\n                token_type=token.token_type,\n            )\n        else:\n            token_response = TokenInactiveIntrospectionResponse()\n\n        content = asdict(token_response)\n\n        return Response(\n            content=content, status_code=HTTPStatus.OK, headers=default_headers\n        )\n\n    def get_client_credentials(\n        self, request: Request, secret_required: bool\n    ) -&gt; Tuple[str, str]:\n        client_id = request.post.client_id\n        client_secret = request.post.client_secret\n\n        if client_id is None or client_secret is None:\n            authorization = request.headers.get(\"Authorization\", \"\")\n\n            # Get client credentials from the Authorization header.\n            try:\n                client_id, client_secret = decode_auth_headers(authorization)\n            except ValueError as exc:\n                if client_id is None or secret_required:\n                    # Either we didn't find a client ID at all, or we found\n                    # a client ID but no secret and a secret is required.\n                    raise InvalidClientError(\n                        description=\"Invalid client_id parameter value.\",\n                        request=request,\n                    ) from exc\n\n        # client_secret must not be None. When client_secret is None,\n        # storage.get_client will not run standard checks on the client_secret\n        if client_secret is None:\n            client_secret = \"\"  # nosec\n\n        return client_id, client_secret\n\n    @catch_errors_and_unavailability()\n    async def create_token_response(self, request: Request) -&gt; Response:\n        \"\"\"Endpoint to obtain an access and/or ID token by presenting an\n        authorization grant or refresh token.\n        Validates a token request and creates a token response.\n        For more information see: [RFC6749 section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3).\n\n        Note:\n            The API endpoint that leverages this function is usually\n            `/token`.\n\n        Example:\n            Below is an example utilizing FastAPI as the server framework.\n\n        ```python\n        from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n        @app.post(\"/token\")\n        async def token(request: fastapi.Request) -&gt; fastapi.Response:\n            # Converts a fastapi.Request to an aioauth.Request.\n            oauth2_request: aioauth.Request = await to_oauth2_request(request)\n            # Creates the response via this function call.\n            oauth2_response: aioauth.Response = await server.create_token_response(oauth2_request)\n            # Converts an aioauth.Response to a fastapi.Response.\n            response: fastapi.Response = await to_fastapi_response(oauth2_response)\n            return response\n        ```\n\n        Args:\n            request: An `aioauth.requests.Request` object.\n\n        Returns:\n            response: An `aioauth.responses.Response` object.\n        \"\"\"\n        self.validate_request(request, [\"POST\"])\n\n        client_secret: Optional[str] = None\n\n        # client_secret is required for the client_credentials grant type\n        # https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/\n        #\n        # for other grant types, client_secret is required if the client has one:\n        # If the client type is confidential or the client was issued client credentials\n        # (or assigned other authentication requirements), the client MUST authenticate\n        # with the authorization server as described in Section 3.2.1.\n        # https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n        secret_required = request.post.grant_type == \"client_credentials\"\n\n        client_id, client_secret = self.get_client_credentials(\n            request, secret_required=secret_required\n        )\n\n        if not request.post.grant_type:\n            # grant_type request value is empty\n            raise InvalidRequestError(\n                request=request, description=\"Request is missing grant type.\"\n            )\n\n        GrantTypeClass: Type[\n            Union[\n                GrantTypeBase,\n                AuthorizationCodeGrantType,\n                PasswordGrantType,\n                RefreshTokenGrantType,\n                ClientCredentialsGrantType,\n            ]\n        ]\n\n        try:\n            GrantTypeClass = self.grant_types[request.post.grant_type]\n        except KeyError as exc:\n            # grant_type request value is invalid\n            raise UnsupportedGrantTypeError(request=request) from exc\n\n        grant_type = GrantTypeClass(\n            storage=self.storage, client_id=client_id, client_secret=client_secret\n        )\n\n        client = await grant_type.validate_request(request)\n\n        response = await grant_type.create_token_response(request, client)\n        content = asdict(response)\n\n        return Response(\n            content=content, status_code=HTTPStatus.OK, headers=default_headers\n        )\n\n    async def validate_authorization_request(\n        self, request: Request\n    ) -&gt; AuthorizationState:\n        \"\"\"\n        Endpoint to interact with the resource owner and obtain an\n        authoriation grant.\n        Validate authorization request and return valid authorization\n        state for later response generation.\n        For more information see: [RFC6749 section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n\n        Note:\n            The API endpoint that leverages this function is usually\n            `/authorize`.\n\n        Example:\n            Below is an example utilizing FastAPI as the server framework.\n\n        ```python\n        from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n        @app.post(\"/authorize\")\n        async def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n            # Converts a fastapi.Request to an aioauth.Request.\n            oauth2_request: aioauth.Request = await to_oauth2_request(request)\n            # Validate the oauth request\n            auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n            # Creates the response via this function call.\n            oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n            # Converts an aioauth.Response to a fastapi.Response.\n            response: fastapi.Response = await to_fastapi_response(oauth2_response)\n            return response\n        ```\n\n        Args:\n            request: An `aioauth.requests.Request` object.\n\n        Returns:\n            state: An `aioauth.server.AuthState` object.\n        \"\"\"\n        self.validate_request(request, [\"GET\", \"POST\"])\n\n        response_type_list = enforce_list(request.query.response_type)\n        response_type_classes: Set[\n            Union[\n                type[ResponseTypeToken],\n                type[ResponseTypeAuthorizationCode],\n                type[ResponseTypeNone],\n                type[ResponseTypeIdToken],\n            ]\n        ] = set()\n        state = request.query.state\n\n        if not response_type_list:\n            raise InvalidRequestError(\n                request=request,\n                description=\"Missing response_type parameter.\",\n                state=state,\n            )\n\n        for response_type in response_type_list:\n            ResponseTypeClass = self.response_types.get(response_type)\n            if ResponseTypeClass:\n                response_type_classes.add(ResponseTypeClass)\n\n        if not response_type_classes:\n            raise UnsupportedResponseTypeError(request=request, state=state)\n\n        auth_state = AuthorizationState(request, response_type_list, grants=[])\n\n        for ResponseTypeClass in response_type_classes:\n            response_type = ResponseTypeClass(storage=self.storage)\n            client = await response_type.validate_request(request)\n            auth_state.grants.append((response_type, client))\n        return auth_state\n\n    async def finalize_authorization_response(\n        self, auth_state: AuthorizationState\n    ) -&gt; Response:\n        \"\"\"\n        Finalizes the authorization response based on the provided authorization state.\n\n        This is the final step in creating an authorization response before sending it to\n        the client.\n\n        Args:\n            auth_state (AuthorizationState): The current authorization state, including the\n                original request, response types, and associated grants.\n\n        Returns:\n            Response: An HTTP response object with the appropriate redirection headers and content.\n        \"\"\"\n        request = auth_state.request\n        state = auth_state.request.query.state\n        response_type_list = auth_state.response_type_list\n\n        # Combined responses\n        responses = {}\n\n        # URI fragment\n        fragment = {}\n\n        # URI query params\n        query = {}\n\n        # Response content\n        content = {}\n        if state:\n            responses[\"state\"] = state\n\n        for response_type, client in auth_state.grants:\n            response = await response_type.create_authorization_response(\n                request, client\n            )\n            response_asdict = asdict(response)\n            if (\n                isinstance(response_type, ResponseTypeToken)\n                and not request.settings.ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT\n            ):\n                # This is the implicit grant where the generation of refresh token has\n                # been disabled in settings\n                response_asdict.pop(\"refresh_token\")\n                response_asdict.pop(\"refresh_token_expires_in\")\n            responses.update(response_asdict)\n\n        # See: https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#Combinations\n        if \"code\" in response_type_list:\n            \"\"\"\n            The TYPE_CODE has lowest priority.\n            The response will be placed in query.\n            \"\"\"\n            query = responses\n\n        if \"token\" in response_type_list:\n            \"\"\"\n            The TYPE_TOKEN has middle priority.\n            The response will be placed in fragment.\n            \"\"\"\n            query = {}\n            fragment = responses\n\n        if \"id_token\" in response_type_list:\n            \"\"\"\n            The TYPE_ID_TOKEN has highest priority.\n            The response can be placed in query, fragment or content\n            depending on the response_mode.\n            \"\"\"\n            if request.query.response_mode == \"form_post\":\n                query = {}\n                fragment = {}\n                content = responses\n            elif request.query.response_mode == \"fragment\":\n                query = {}\n                content = {}\n                fragment = responses\n            elif request.query.response_mode == \"query\":\n                content = {}\n                fragment = {}\n                query = responses\n\n        location = build_uri(request.query.redirect_uri, query, fragment)\n\n        return Response(\n            status_code=HTTPStatus.FOUND,\n            headers=HTTPHeaderDict({\"location\": location}),\n            content=content,\n        )\n\n    @catch_errors_and_unavailability(\n        skip_redirect_on_exc=(\n            MethodNotAllowedError,\n            InvalidClientError,\n            InvalidRedirectURIError,\n        )\n    )\n    async def create_authorization_response(self, request: Request) -&gt; Response:\n        \"\"\"\n        Endpoint to interact with the resource owner and obtain an\n        authorization grant.\n        Create an authorization response after validation.\n        For more information see: [RFC6749 section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n\n        Example:\n            Below is an example utilizing FastAPI as the server framework.\n\n        ```python\n        from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n        @app.post(\"/authorize\")\n        async def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n            # Converts a fastapi.Request to an aioauth.Request.\n            oauth2_request: aioauth.Request = await to_oauth2_request(request)\n            # Validate the oauth request\n            auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n            # Creates the response via this function call.\n            oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n            # Converts an aioauth.Response to a fastapi.Response.\n            response: fastapi.Response = await to_fastapi_response(oauth2_response)\n            return response\n        ```\n\n        Args:\n            auth_state: An `aioauth.server.AuthState` object.\n\n        Returns:\n            response: An `aioauth.responses.Response` object.\n        \"\"\"\n        auth_state = await self.validate_authorization_request(request)\n        return await self.finalize_authorization_response(auth_state)\n\n    @catch_errors_and_unavailability()\n    async def revoke_token(self, request: Request) -&gt; Response:\n        \"\"\"Endpoint to revoke an access token or refresh token.\n        For more information see: [RFC7009](https://tools.ietf.org/html/rfc7009).\n\n        Note:\n            The API endpoint that leverages this function is usually\n            `/revoke`.\n        Example:\n            Below is an example utilizing FastAPI as the server framework.\n\n        ```python\n        from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n        @app.post(\"/revoke\")\n        async def revoke(request: fastapi.Request) -&gt; fastapi.Response:\n            # Converts a fastapi.Request to an aioauth.Request.\n            oauth2_request: aioauth.Request = await to_oauth2_request(request)\n            # Creates the response via this function call.\n            oauth2_response: aioauth.Response = await server.revoke_token(oauth2_request)\n            # Converts an aioauth.Response to a fastapi.Response.\n            response: fastapi.Response = await to_fastapi_response(oauth2_response)\n            return response\n        ```\n\n        Args:\n            request: An `aioauth.requests.Request` object.\n\n        Returns:\n            response: An `aioauth.responses.Response` object.\n        \"\"\"\n        self.validate_request(request, [\"POST\"])\n        client_id, client_secret = self.get_client_credentials(\n            request, secret_required=False\n        )\n\n        client = await self.storage.get_client(\n            request=request, client_id=client_id, client_secret=client_secret\n        )\n\n        if not client:\n            raise InvalidClientError(request)\n\n        if not request.post.token:\n            raise InvalidRequestError(\n                request=request, description=\"Request is missing token.\"\n            )\n\n        if request.post.token_type_hint and request.post.token_type_hint not in {\n            \"refresh_token\",\n            \"access_token\",\n        }:\n            raise UnsupportedTokenTypeError(request=request)\n\n        access_token = (\n            request.post.token\n            if request.post.token_type_hint != \"refresh_token\"  # nosec\n            else None\n        )\n        refresh_token = (\n            request.post.token\n            if request.post.token_type_hint != \"access_token\"  # nosec\n            else None\n        )\n\n        token = await self.storage.get_token(\n            request=request,\n            client_id=client_id,\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=request.post.token_type_hint,\n        )\n\n        if token:\n            await self.storage.revoke_token(\n                request=request,\n                client_id=client_id,\n                access_token=access_token,\n                refresh_token=refresh_token,\n                token_type=request.post.token_type_hint,\n            )\n\n        return Response(status_code=HTTPStatus.NO_CONTENT)\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.create_authorization_response","title":"<code>create_authorization_response(request)</code>  <code>async</code>","text":"<p>Endpoint to interact with the resource owner and obtain an authorization grant. Create an authorization response after validation. For more information see: RFC6749 section 4.1.1.</p> Example <p>Below is an example utilizing FastAPI as the server framework.</p> <pre><code>from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n@app.post(\"/authorize\")\nasync def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n    # Converts a fastapi.Request to an aioauth.Request.\n    oauth2_request: aioauth.Request = await to_oauth2_request(request)\n    # Validate the oauth request\n    auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n    # Creates the response via this function call.\n    oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n    # Converts an aioauth.Response to a fastapi.Response.\n    response: fastapi.Response = await to_fastapi_response(oauth2_response)\n    return response\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>auth_state</code> <p>An <code>aioauth.server.AuthState</code> object.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Response</code> <p>An <code>aioauth.responses.Response</code> object.</p> Source code in <code>aioauth/server.py</code> <pre><code>@catch_errors_and_unavailability(\n    skip_redirect_on_exc=(\n        MethodNotAllowedError,\n        InvalidClientError,\n        InvalidRedirectURIError,\n    )\n)\nasync def create_authorization_response(self, request: Request) -&gt; Response:\n    \"\"\"\n    Endpoint to interact with the resource owner and obtain an\n    authorization grant.\n    Create an authorization response after validation.\n    For more information see: [RFC6749 section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n\n    Example:\n        Below is an example utilizing FastAPI as the server framework.\n\n    ```python\n    from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n    @app.post(\"/authorize\")\n    async def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n        # Converts a fastapi.Request to an aioauth.Request.\n        oauth2_request: aioauth.Request = await to_oauth2_request(request)\n        # Validate the oauth request\n        auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n        # Creates the response via this function call.\n        oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n        # Converts an aioauth.Response to a fastapi.Response.\n        response: fastapi.Response = await to_fastapi_response(oauth2_response)\n        return response\n    ```\n\n    Args:\n        auth_state: An `aioauth.server.AuthState` object.\n\n    Returns:\n        response: An `aioauth.responses.Response` object.\n    \"\"\"\n    auth_state = await self.validate_authorization_request(request)\n    return await self.finalize_authorization_response(auth_state)\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.create_token_introspection_response","title":"<code>create_token_introspection_response(request)</code>  <code>async</code>","text":"<p>Returns a response object with introspection of the passed token. For more information see RFC7662 section 2.1.</p> Note <p>The API endpoint that leverages this function is usually <code>/introspect</code>.</p> Example <p>Below is an example utilizing FastAPI as the server framework.</p> <pre><code>from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n@app.get(\"/token/introspect\")\nasync def introspect(request: fastapi.Request) -&gt; fastapi.Response:\n    # Converts a fastapi.Request to an aioauth.Request.\n    oauth2_request: aioauth.Request = await to_oauth2_request(request)\n    # Creates the response via this function call.\n    oauth2_response: aioauth.Response = await server.create_token_introspection_response(oauth2_request)\n    # Converts an aioauth.Response to a fastapi.Response.\n    response: fastapi.Response = await to_fastapi_response(oauth2_response)\n    return response\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code> object.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Response</code> <p>An <code>aioauth.responses.Response</code> object.</p> Source code in <code>aioauth/server.py</code> <pre><code>@catch_errors_and_unavailability()\nasync def create_token_introspection_response(self, request: Request) -&gt; Response:\n    \"\"\"\n    Returns a response object with introspection of the passed token.\n    For more information see [RFC7662 section 2.1](https://tools.ietf.org/html/rfc7662#section-2.1).\n\n    Note:\n        The API endpoint that leverages this function is usually\n        `/introspect`.\n\n    Example:\n        Below is an example utilizing FastAPI as the server framework.\n\n    ```python\n    from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n    @app.get(\"/token/introspect\")\n    async def introspect(request: fastapi.Request) -&gt; fastapi.Response:\n        # Converts a fastapi.Request to an aioauth.Request.\n        oauth2_request: aioauth.Request = await to_oauth2_request(request)\n        # Creates the response via this function call.\n        oauth2_response: aioauth.Response = await server.create_token_introspection_response(oauth2_request)\n        # Converts an aioauth.Response to a fastapi.Response.\n        response: fastapi.Response = await to_fastapi_response(oauth2_response)\n        return response\n    ```\n\n    Args:\n        request: An `aioauth.requests.Request` object.\n\n    Returns:\n        response: An `aioauth.responses.Response` object.\n    \"\"\"\n    self.validate_request(request, [\"POST\"])\n    client_id, client_secret = self.get_client_credentials(\n        request, secret_required=True\n    )\n\n    client = await self.storage.get_client(\n        request=request, client_id=client_id, client_secret=client_secret\n    )\n\n    if not client:\n        raise InvalidClientError(request)\n\n    token_types: Tuple[TokenType, ...] = get_args(TokenType)\n    token_type: TokenType = \"refresh_token\"\n\n    access_token = None\n    refresh_token = request.post.token\n\n    if request.post.token_type_hint in token_types:\n        token_type = request.post.token_type_hint\n\n    if token_type == \"access_token\":  # nosec\n        access_token = request.post.token\n        refresh_token = None\n\n    token = await self.storage.get_token(\n        request=request,\n        client_id=client_id,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=token_type,\n    )\n\n    token_response: Union[\n        TokenInactiveIntrospectionResponse, TokenActiveIntrospectionResponse\n    ]\n\n    if token and not token.is_expired and not token.revoked:\n        token_response = TokenActiveIntrospectionResponse(\n            scope=token.scope,\n            client_id=token.client_id,\n            expires_in=token.expires_in,\n            token_type=token.token_type,\n        )\n    else:\n        token_response = TokenInactiveIntrospectionResponse()\n\n    content = asdict(token_response)\n\n    return Response(\n        content=content, status_code=HTTPStatus.OK, headers=default_headers\n    )\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.create_token_response","title":"<code>create_token_response(request)</code>  <code>async</code>","text":"<p>Endpoint to obtain an access and/or ID token by presenting an authorization grant or refresh token. Validates a token request and creates a token response. For more information see: RFC6749 section 4.1.3.</p> Note <p>The API endpoint that leverages this function is usually <code>/token</code>.</p> Example <p>Below is an example utilizing FastAPI as the server framework.</p> <pre><code>from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n@app.post(\"/token\")\nasync def token(request: fastapi.Request) -&gt; fastapi.Response:\n    # Converts a fastapi.Request to an aioauth.Request.\n    oauth2_request: aioauth.Request = await to_oauth2_request(request)\n    # Creates the response via this function call.\n    oauth2_response: aioauth.Response = await server.create_token_response(oauth2_request)\n    # Converts an aioauth.Response to a fastapi.Response.\n    response: fastapi.Response = await to_fastapi_response(oauth2_response)\n    return response\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code> object.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Response</code> <p>An <code>aioauth.responses.Response</code> object.</p> Source code in <code>aioauth/server.py</code> <pre><code>@catch_errors_and_unavailability()\nasync def create_token_response(self, request: Request) -&gt; Response:\n    \"\"\"Endpoint to obtain an access and/or ID token by presenting an\n    authorization grant or refresh token.\n    Validates a token request and creates a token response.\n    For more information see: [RFC6749 section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3).\n\n    Note:\n        The API endpoint that leverages this function is usually\n        `/token`.\n\n    Example:\n        Below is an example utilizing FastAPI as the server framework.\n\n    ```python\n    from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n    @app.post(\"/token\")\n    async def token(request: fastapi.Request) -&gt; fastapi.Response:\n        # Converts a fastapi.Request to an aioauth.Request.\n        oauth2_request: aioauth.Request = await to_oauth2_request(request)\n        # Creates the response via this function call.\n        oauth2_response: aioauth.Response = await server.create_token_response(oauth2_request)\n        # Converts an aioauth.Response to a fastapi.Response.\n        response: fastapi.Response = await to_fastapi_response(oauth2_response)\n        return response\n    ```\n\n    Args:\n        request: An `aioauth.requests.Request` object.\n\n    Returns:\n        response: An `aioauth.responses.Response` object.\n    \"\"\"\n    self.validate_request(request, [\"POST\"])\n\n    client_secret: Optional[str] = None\n\n    # client_secret is required for the client_credentials grant type\n    # https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/\n    #\n    # for other grant types, client_secret is required if the client has one:\n    # If the client type is confidential or the client was issued client credentials\n    # (or assigned other authentication requirements), the client MUST authenticate\n    # with the authorization server as described in Section 3.2.1.\n    # https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n    secret_required = request.post.grant_type == \"client_credentials\"\n\n    client_id, client_secret = self.get_client_credentials(\n        request, secret_required=secret_required\n    )\n\n    if not request.post.grant_type:\n        # grant_type request value is empty\n        raise InvalidRequestError(\n            request=request, description=\"Request is missing grant type.\"\n        )\n\n    GrantTypeClass: Type[\n        Union[\n            GrantTypeBase,\n            AuthorizationCodeGrantType,\n            PasswordGrantType,\n            RefreshTokenGrantType,\n            ClientCredentialsGrantType,\n        ]\n    ]\n\n    try:\n        GrantTypeClass = self.grant_types[request.post.grant_type]\n    except KeyError as exc:\n        # grant_type request value is invalid\n        raise UnsupportedGrantTypeError(request=request) from exc\n\n    grant_type = GrantTypeClass(\n        storage=self.storage, client_id=client_id, client_secret=client_secret\n    )\n\n    client = await grant_type.validate_request(request)\n\n    response = await grant_type.create_token_response(request, client)\n    content = asdict(response)\n\n    return Response(\n        content=content, status_code=HTTPStatus.OK, headers=default_headers\n    )\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.finalize_authorization_response","title":"<code>finalize_authorization_response(auth_state)</code>  <code>async</code>","text":"<p>Finalizes the authorization response based on the provided authorization state.</p> <p>This is the final step in creating an authorization response before sending it to the client.</p> <p>Parameters:</p> Name Type Description Default <code>auth_state</code> <code>AuthorizationState</code> <p>The current authorization state, including the original request, response types, and associated grants.</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>An HTTP response object with the appropriate redirection headers and content.</p> Source code in <code>aioauth/server.py</code> <pre><code>async def finalize_authorization_response(\n    self, auth_state: AuthorizationState\n) -&gt; Response:\n    \"\"\"\n    Finalizes the authorization response based on the provided authorization state.\n\n    This is the final step in creating an authorization response before sending it to\n    the client.\n\n    Args:\n        auth_state (AuthorizationState): The current authorization state, including the\n            original request, response types, and associated grants.\n\n    Returns:\n        Response: An HTTP response object with the appropriate redirection headers and content.\n    \"\"\"\n    request = auth_state.request\n    state = auth_state.request.query.state\n    response_type_list = auth_state.response_type_list\n\n    # Combined responses\n    responses = {}\n\n    # URI fragment\n    fragment = {}\n\n    # URI query params\n    query = {}\n\n    # Response content\n    content = {}\n    if state:\n        responses[\"state\"] = state\n\n    for response_type, client in auth_state.grants:\n        response = await response_type.create_authorization_response(\n            request, client\n        )\n        response_asdict = asdict(response)\n        if (\n            isinstance(response_type, ResponseTypeToken)\n            and not request.settings.ISSUE_REFRESH_TOKEN_IMPLICIT_GRANT\n        ):\n            # This is the implicit grant where the generation of refresh token has\n            # been disabled in settings\n            response_asdict.pop(\"refresh_token\")\n            response_asdict.pop(\"refresh_token_expires_in\")\n        responses.update(response_asdict)\n\n    # See: https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#Combinations\n    if \"code\" in response_type_list:\n        \"\"\"\n        The TYPE_CODE has lowest priority.\n        The response will be placed in query.\n        \"\"\"\n        query = responses\n\n    if \"token\" in response_type_list:\n        \"\"\"\n        The TYPE_TOKEN has middle priority.\n        The response will be placed in fragment.\n        \"\"\"\n        query = {}\n        fragment = responses\n\n    if \"id_token\" in response_type_list:\n        \"\"\"\n        The TYPE_ID_TOKEN has highest priority.\n        The response can be placed in query, fragment or content\n        depending on the response_mode.\n        \"\"\"\n        if request.query.response_mode == \"form_post\":\n            query = {}\n            fragment = {}\n            content = responses\n        elif request.query.response_mode == \"fragment\":\n            query = {}\n            content = {}\n            fragment = responses\n        elif request.query.response_mode == \"query\":\n            content = {}\n            fragment = {}\n            query = responses\n\n    location = build_uri(request.query.redirect_uri, query, fragment)\n\n    return Response(\n        status_code=HTTPStatus.FOUND,\n        headers=HTTPHeaderDict({\"location\": location}),\n        content=content,\n    )\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.is_secure_transport","title":"<code>is_secure_transport(request)</code>","text":"<p>Verifies the request was sent via a protected SSL tunnel.</p> Note <p>This method checks if the request URL contains <code>https://</code> at the start of it. For production use, additional SSL certificate validation should be implemented at the web server level (nginx, Apache) or load balancer.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p><code>aioauth.requests.Request</code> object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Flag representing whether or not the transport is secure.</p> Source code in <code>aioauth/server.py</code> <pre><code>def is_secure_transport(self, request: Request) -&gt; bool:\n    \"\"\"\n    Verifies the request was sent via a protected SSL tunnel.\n\n    Note:\n        This method checks if the request URL contains\n        ``https://`` at the start of it. For production use,\n        additional SSL certificate validation should be implemented\n        at the web server level (nginx, Apache) or load balancer.\n\n    Args:\n        request: `aioauth.requests.Request` object.\n\n    Returns:\n        Flag representing whether or not the transport is secure.\n    \"\"\"\n    if request.settings.INSECURE_TRANSPORT:\n        return True\n\n    # Check for HTTPS scheme\n    if not request.url.lower().startswith(\"https://\"):\n        return False\n\n    # Additional check for X-Forwarded-Proto header (for load balancers/proxies)\n    forwarded_proto = request.headers.get(\"X-Forwarded-Proto\", \"\").lower()\n    if forwarded_proto and forwarded_proto != \"https\":\n        return False\n\n    return True\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.revoke_token","title":"<code>revoke_token(request)</code>  <code>async</code>","text":"<p>Endpoint to revoke an access token or refresh token. For more information see: RFC7009.</p> Note <p>The API endpoint that leverages this function is usually <code>/revoke</code>.</p> <p>Example:     Below is an example utilizing FastAPI as the server framework.</p> <pre><code>from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n@app.post(\"/revoke\")\nasync def revoke(request: fastapi.Request) -&gt; fastapi.Response:\n    # Converts a fastapi.Request to an aioauth.Request.\n    oauth2_request: aioauth.Request = await to_oauth2_request(request)\n    # Creates the response via this function call.\n    oauth2_response: aioauth.Response = await server.revoke_token(oauth2_request)\n    # Converts an aioauth.Response to a fastapi.Response.\n    response: fastapi.Response = await to_fastapi_response(oauth2_response)\n    return response\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code> object.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Response</code> <p>An <code>aioauth.responses.Response</code> object.</p> Source code in <code>aioauth/server.py</code> <pre><code>@catch_errors_and_unavailability()\nasync def revoke_token(self, request: Request) -&gt; Response:\n    \"\"\"Endpoint to revoke an access token or refresh token.\n    For more information see: [RFC7009](https://tools.ietf.org/html/rfc7009).\n\n    Note:\n        The API endpoint that leverages this function is usually\n        `/revoke`.\n    Example:\n        Below is an example utilizing FastAPI as the server framework.\n\n    ```python\n    from aioauth_fastapi.utils import to_oauth2_request, to_fastapi_response\n\n    @app.post(\"/revoke\")\n    async def revoke(request: fastapi.Request) -&gt; fastapi.Response:\n        # Converts a fastapi.Request to an aioauth.Request.\n        oauth2_request: aioauth.Request = await to_oauth2_request(request)\n        # Creates the response via this function call.\n        oauth2_response: aioauth.Response = await server.revoke_token(oauth2_request)\n        # Converts an aioauth.Response to a fastapi.Response.\n        response: fastapi.Response = await to_fastapi_response(oauth2_response)\n        return response\n    ```\n\n    Args:\n        request: An `aioauth.requests.Request` object.\n\n    Returns:\n        response: An `aioauth.responses.Response` object.\n    \"\"\"\n    self.validate_request(request, [\"POST\"])\n    client_id, client_secret = self.get_client_credentials(\n        request, secret_required=False\n    )\n\n    client = await self.storage.get_client(\n        request=request, client_id=client_id, client_secret=client_secret\n    )\n\n    if not client:\n        raise InvalidClientError(request)\n\n    if not request.post.token:\n        raise InvalidRequestError(\n            request=request, description=\"Request is missing token.\"\n        )\n\n    if request.post.token_type_hint and request.post.token_type_hint not in {\n        \"refresh_token\",\n        \"access_token\",\n    }:\n        raise UnsupportedTokenTypeError(request=request)\n\n    access_token = (\n        request.post.token\n        if request.post.token_type_hint != \"refresh_token\"  # nosec\n        else None\n    )\n    refresh_token = (\n        request.post.token\n        if request.post.token_type_hint != \"access_token\"  # nosec\n        else None\n    )\n\n    token = await self.storage.get_token(\n        request=request,\n        client_id=client_id,\n        access_token=access_token,\n        refresh_token=refresh_token,\n        token_type=request.post.token_type_hint,\n    )\n\n    if token:\n        await self.storage.revoke_token(\n            request=request,\n            client_id=client_id,\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=request.post.token_type_hint,\n        )\n\n    return Response(status_code=HTTPStatus.NO_CONTENT)\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationServer.validate_authorization_request","title":"<code>validate_authorization_request(request)</code>  <code>async</code>","text":"<p>Endpoint to interact with the resource owner and obtain an authoriation grant. Validate authorization request and return valid authorization state for later response generation. For more information see: RFC6749 section 4.1.1.</p> Note <p>The API endpoint that leverages this function is usually <code>/authorize</code>.</p> Example <p>Below is an example utilizing FastAPI as the server framework.</p> <pre><code>from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n@app.post(\"/authorize\")\nasync def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n    # Converts a fastapi.Request to an aioauth.Request.\n    oauth2_request: aioauth.Request = await to_oauth2_request(request)\n    # Validate the oauth request\n    auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n    # Creates the response via this function call.\n    oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n    # Converts an aioauth.Response to a fastapi.Response.\n    response: fastapi.Response = await to_fastapi_response(oauth2_response)\n    return response\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code> object.</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>AuthorizationState</code> <p>An <code>aioauth.server.AuthState</code> object.</p> Source code in <code>aioauth/server.py</code> <pre><code>async def validate_authorization_request(\n    self, request: Request\n) -&gt; AuthorizationState:\n    \"\"\"\n    Endpoint to interact with the resource owner and obtain an\n    authoriation grant.\n    Validate authorization request and return valid authorization\n    state for later response generation.\n    For more information see: [RFC6749 section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n\n    Note:\n        The API endpoint that leverages this function is usually\n        `/authorize`.\n\n    Example:\n        Below is an example utilizing FastAPI as the server framework.\n\n    ```python\n    from aioauth.fastapi.utils import to_oauth2_request, to_fastapi_response\n\n    @app.post(\"/authorize\")\n    async def authorize(request: fastapi.Request) -&gt; fastapi.Response:\n        # Converts a fastapi.Request to an aioauth.Request.\n        oauth2_request: aioauth.Request = await to_oauth2_request(request)\n        # Validate the oauth request\n        auth_state: aioauth.AuthState = await server.validate_authorization_request(oauth2_request)\n        # Creates the response via this function call.\n        oauth2_response: aioauth.Response = await server.create_authorization_response(auth_state)\n        # Converts an aioauth.Response to a fastapi.Response.\n        response: fastapi.Response = await to_fastapi_response(oauth2_response)\n        return response\n    ```\n\n    Args:\n        request: An `aioauth.requests.Request` object.\n\n    Returns:\n        state: An `aioauth.server.AuthState` object.\n    \"\"\"\n    self.validate_request(request, [\"GET\", \"POST\"])\n\n    response_type_list = enforce_list(request.query.response_type)\n    response_type_classes: Set[\n        Union[\n            type[ResponseTypeToken],\n            type[ResponseTypeAuthorizationCode],\n            type[ResponseTypeNone],\n            type[ResponseTypeIdToken],\n        ]\n    ] = set()\n    state = request.query.state\n\n    if not response_type_list:\n        raise InvalidRequestError(\n            request=request,\n            description=\"Missing response_type parameter.\",\n            state=state,\n        )\n\n    for response_type in response_type_list:\n        ResponseTypeClass = self.response_types.get(response_type)\n        if ResponseTypeClass:\n            response_type_classes.add(ResponseTypeClass)\n\n    if not response_type_classes:\n        raise UnsupportedResponseTypeError(request=request, state=state)\n\n    auth_state = AuthorizationState(request, response_type_list, grants=[])\n\n    for ResponseTypeClass in response_type_classes:\n        response_type = ResponseTypeClass(storage=self.storage)\n        client = await response_type.validate_request(request)\n        auth_state.grants.append((response_type, client))\n    return auth_state\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationState","title":"<code>AuthorizationState</code>  <code>dataclass</code>","text":"<p>AuthorizationServer state object used in Authorization Code process.</p> Source code in <code>aioauth/server.py</code> <pre><code>@dataclass\nclass AuthorizationState:\n    \"\"\"AuthorizationServer state object used in Authorization Code process.\"\"\"\n\n    request: Request\n    \"\"\"OAuth2.0 Authorization Code Request Object\"\"\"\n\n    response_type_list: List[ResponseType]\n    \"\"\"Supported ResponseTypes Collected During Initial Request Validation\"\"\"\n\n    grants: List[\n        Tuple[\n            Union[\n                ResponseTypeToken,\n                ResponseTypeAuthorizationCode,\n                ResponseTypeNone,\n                ResponseTypeIdToken,\n            ],\n            Client,\n        ]\n    ]\n    \"\"\"Collection of Supported GrantType Handlers and The Parsed Clients\"\"\"\n</code></pre>"},{"location":"sections/api/server/#aioauth.server.AuthorizationState.grants","title":"<code>grants</code>  <code>instance-attribute</code>","text":"<p>Collection of Supported GrantType Handlers and The Parsed Clients</p>"},{"location":"sections/api/server/#aioauth.server.AuthorizationState.request","title":"<code>request</code>  <code>instance-attribute</code>","text":"<p>OAuth2.0 Authorization Code Request Object</p>"},{"location":"sections/api/server/#aioauth.server.AuthorizationState.response_type_list","title":"<code>response_type_list</code>  <code>instance-attribute</code>","text":"<p>Supported ResponseTypes Collected During Initial Request Validation</p>"},{"location":"sections/api/storage/","title":"Storage","text":"<p>Storage helper class for storing and retrieving client and resource owner information. See the examples on the sidebar to view this in action. <pre><code>from aioauth import storage\n</code></pre></p>"},{"location":"sections/api/storage/#aioauth.storage.AuthorizationCodeStorage","title":"<code>AuthorizationCodeStorage</code>","text":"Source code in <code>aioauth/storage.py</code> <pre><code>class AuthorizationCodeStorage:\n    async def create_authorization_code(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        scope: str,\n        response_type: str,\n        redirect_uri: str,\n        code: str,\n        code_challenge_method: Optional[CodeChallengeMethod] = None,\n        code_challenge: Optional[str] = None,\n        nonce: Optional[str] = None,\n    ) -&gt; AuthorizationCode:\n        \"\"\"Generates an authorization token and stores it in the database.\n\n        Warning:\n            Generated authorization token *must* be stored in the database.\n\n        Note:\n            This must is used by the response type\n            `aioauth.respose_type.ResponseTypeAuthorizationCode`.\n\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            scope: The scopes for the token.\n            response_type: An `aioauth.types.ResponseType`.\n            redirect_uri: The redirect URI.\n            code_challenge_method: An `aioauth.types.CodeChallengeMethod`.\n            code_challenge: Code challenge string.\n\n        Returns:\n            An `aioauth.models.AuthorizationCode` object.\n        \"\"\"\n        raise NotImplementedError(\n            \"Method create_authorization_code must be implemented\"\n        )\n\n    async def get_authorization_code(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        code: str,\n    ) -&gt; Optional[AuthorizationCode]:\n        \"\"\"Gets existing authorization code from the database if it exists.\n\n        Warning:\n            If authorization code does not exists this function *must*\n            return ``None`` to indicate to the validator that the\n            requested authorization code does not exist or is invalid.\n\n        Note:\n            This method is used by the grant type\n            `aioauth.grant_type.AuthorizationCodeGrantType`.\n\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            code: An authorization code.\n\n        Returns:\n            An optional `aioauth.models.AuthorizationCode`.\n        \"\"\"\n        raise NotImplementedError(\n            \"Method get_authorization_code must be implemented for AuthorizationCodeGrantType\"\n        )\n\n    async def delete_authorization_code(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        code: str,\n    ) -&gt; None:\n        \"\"\"Deletes authorization code from database.\n\n        Note:\n            This method is used by the grant type\n            `aioauth.grant_type.AuthorizationCodeGrantType`.\n\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            code: An authorization code.\n        \"\"\"\n        raise NotImplementedError(\n            \"Method delete_authorization_code must be implemented for AuthorizationCodeGrantType\"\n        )\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.AuthorizationCodeStorage.create_authorization_code","title":"<code>create_authorization_code(*, request, client_id, scope, response_type, redirect_uri, code, code_challenge_method=None, code_challenge=None, nonce=None)</code>  <code>async</code>","text":"<p>Generates an authorization token and stores it in the database.</p> Warning <p>Generated authorization token must be stored in the database.</p> Note <p>This must is used by the response type <code>aioauth.respose_type.ResponseTypeAuthorizationCode</code>.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code>.</p> required <code>client_id</code> <code>str</code> <p>A user client ID.</p> required <code>scope</code> <code>str</code> <p>The scopes for the token.</p> required <code>response_type</code> <code>str</code> <p>An <code>aioauth.types.ResponseType</code>.</p> required <code>redirect_uri</code> <code>str</code> <p>The redirect URI.</p> required <code>code_challenge_method</code> <code>Optional[CodeChallengeMethod]</code> <p>An <code>aioauth.types.CodeChallengeMethod</code>.</p> <code>None</code> <code>code_challenge</code> <code>Optional[str]</code> <p>Code challenge string.</p> <code>None</code> <p>Returns:</p> Type Description <code>AuthorizationCode</code> <p>An <code>aioauth.models.AuthorizationCode</code> object.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def create_authorization_code(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    scope: str,\n    response_type: str,\n    redirect_uri: str,\n    code: str,\n    code_challenge_method: Optional[CodeChallengeMethod] = None,\n    code_challenge: Optional[str] = None,\n    nonce: Optional[str] = None,\n) -&gt; AuthorizationCode:\n    \"\"\"Generates an authorization token and stores it in the database.\n\n    Warning:\n        Generated authorization token *must* be stored in the database.\n\n    Note:\n        This must is used by the response type\n        `aioauth.respose_type.ResponseTypeAuthorizationCode`.\n\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        scope: The scopes for the token.\n        response_type: An `aioauth.types.ResponseType`.\n        redirect_uri: The redirect URI.\n        code_challenge_method: An `aioauth.types.CodeChallengeMethod`.\n        code_challenge: Code challenge string.\n\n    Returns:\n        An `aioauth.models.AuthorizationCode` object.\n    \"\"\"\n    raise NotImplementedError(\n        \"Method create_authorization_code must be implemented\"\n    )\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.AuthorizationCodeStorage.delete_authorization_code","title":"<code>delete_authorization_code(*, request, client_id, code)</code>  <code>async</code>","text":"<p>Deletes authorization code from database.</p> Note <p>This method is used by the grant type <code>aioauth.grant_type.AuthorizationCodeGrantType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code>.</p> required <code>client_id</code> <code>str</code> <p>A user client ID.</p> required <code>code</code> <code>str</code> <p>An authorization code.</p> required Source code in <code>aioauth/storage.py</code> <pre><code>async def delete_authorization_code(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    code: str,\n) -&gt; None:\n    \"\"\"Deletes authorization code from database.\n\n    Note:\n        This method is used by the grant type\n        `aioauth.grant_type.AuthorizationCodeGrantType`.\n\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        code: An authorization code.\n    \"\"\"\n    raise NotImplementedError(\n        \"Method delete_authorization_code must be implemented for AuthorizationCodeGrantType\"\n    )\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.AuthorizationCodeStorage.get_authorization_code","title":"<code>get_authorization_code(*, request, client_id, code)</code>  <code>async</code>","text":"<p>Gets existing authorization code from the database if it exists.</p> Warning <p>If authorization code does not exists this function must return <code>None</code> to indicate to the validator that the requested authorization code does not exist or is invalid.</p> Note <p>This method is used by the grant type <code>aioauth.grant_type.AuthorizationCodeGrantType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code>.</p> required <code>client_id</code> <code>str</code> <p>A user client ID.</p> required <code>code</code> <code>str</code> <p>An authorization code.</p> required <p>Returns:</p> Type Description <code>Optional[AuthorizationCode]</code> <p>An optional <code>aioauth.models.AuthorizationCode</code>.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def get_authorization_code(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    code: str,\n) -&gt; Optional[AuthorizationCode]:\n    \"\"\"Gets existing authorization code from the database if it exists.\n\n    Warning:\n        If authorization code does not exists this function *must*\n        return ``None`` to indicate to the validator that the\n        requested authorization code does not exist or is invalid.\n\n    Note:\n        This method is used by the grant type\n        `aioauth.grant_type.AuthorizationCodeGrantType`.\n\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        code: An authorization code.\n\n    Returns:\n        An optional `aioauth.models.AuthorizationCode`.\n    \"\"\"\n    raise NotImplementedError(\n        \"Method get_authorization_code must be implemented for AuthorizationCodeGrantType\"\n    )\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.ClientStorage","title":"<code>ClientStorage</code>","text":"Source code in <code>aioauth/storage.py</code> <pre><code>class ClientStorage:\n    async def get_client(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        client_secret: Optional[str] = None,\n    ) -&gt; Optional[Client]:\n        \"\"\"Gets existing client from the database if it exists.\n\n        Warning:\n            If client does not exists in database this method *must*\n            return `None` to indicate to the validator that the\n            requested `client_id` does not exist or is invalid.\n\n        Note:\n            This method is used by all core grant types, as well as\n            all core response types.\n\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            client_secret: An optional user client secret.\n\n        Returns:\n            An optional `aioauth.models.Client` object.\n        \"\"\"\n        raise NotImplementedError(\"Method get_client must be implemented\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.ClientStorage.get_client","title":"<code>get_client(*, request, client_id, client_secret=None)</code>  <code>async</code>","text":"<p>Gets existing client from the database if it exists.</p> Warning <p>If client does not exists in database this method must return <code>None</code> to indicate to the validator that the requested <code>client_id</code> does not exist or is invalid.</p> Note <p>This method is used by all core grant types, as well as all core response types.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code>.</p> required <code>client_id</code> <code>str</code> <p>A user client ID.</p> required <code>client_secret</code> <code>Optional[str]</code> <p>An optional user client secret.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Client]</code> <p>An optional <code>aioauth.models.Client</code> object.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def get_client(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    client_secret: Optional[str] = None,\n) -&gt; Optional[Client]:\n    \"\"\"Gets existing client from the database if it exists.\n\n    Warning:\n        If client does not exists in database this method *must*\n        return `None` to indicate to the validator that the\n        requested `client_id` does not exist or is invalid.\n\n    Note:\n        This method is used by all core grant types, as well as\n        all core response types.\n\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        client_secret: An optional user client secret.\n\n    Returns:\n        An optional `aioauth.models.Client` object.\n    \"\"\"\n    raise NotImplementedError(\"Method get_client must be implemented\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.IDTokenStorage","title":"<code>IDTokenStorage</code>","text":"Source code in <code>aioauth/storage.py</code> <pre><code>class IDTokenStorage:\n    async def get_id_token(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        scope: str,\n        redirect_uri: str,\n        response_type: Optional[str] = None,\n        nonce: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"Returns an id_token.\n        For more information see [OpenID Connect Core 1.0 incorporating errata set 1 section 2](https://openid.net/specs/openid-connect-core-1_0.html#IDToken).\n\n        Note:\n            Method is used by response type `aioauth.response_type.ResponseTypeIdToken`\n            and `aioauth.oidc.core.grant_type.AuthorizationCodeGrantType`.\n        \"\"\"\n        raise NotImplementedError(\"get_id_token must be implemented.\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.IDTokenStorage.get_id_token","title":"<code>get_id_token(*, request, client_id, scope, redirect_uri, response_type=None, nonce=None)</code>  <code>async</code>","text":"<p>Returns an id_token. For more information see OpenID Connect Core 1.0 incorporating errata set 1 section 2.</p> Note <p>Method is used by response type <code>aioauth.response_type.ResponseTypeIdToken</code> and <code>aioauth.oidc.core.grant_type.AuthorizationCodeGrantType</code>.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def get_id_token(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    scope: str,\n    redirect_uri: str,\n    response_type: Optional[str] = None,\n    nonce: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Returns an id_token.\n    For more information see [OpenID Connect Core 1.0 incorporating errata set 1 section 2](https://openid.net/specs/openid-connect-core-1_0.html#IDToken).\n\n    Note:\n        Method is used by response type `aioauth.response_type.ResponseTypeIdToken`\n        and `aioauth.oidc.core.grant_type.AuthorizationCodeGrantType`.\n    \"\"\"\n    raise NotImplementedError(\"get_id_token must be implemented.\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.TokenStorage","title":"<code>TokenStorage</code>","text":"Source code in <code>aioauth/storage.py</code> <pre><code>class TokenStorage:\n    async def create_token(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        scope: str,\n        access_token: str,\n        refresh_token: Optional[str] = None,\n    ) -&gt; Token:\n        \"\"\"Generates a user token and stores it in the database.\n\n        Used by:\n\n        * `ResponseTypeToken`\n        * `AuthorizationCodeGrantType`\n        * `PasswordGrantType`\n        * `ClientCredentialsGrantType`\n        * `RefreshTokenGrantType`\n\n        Warning:\n            Generated token *must* be stored in the database.\n        Note:\n            Method is used by all core grant types, but only used for\n            `aioauth.response_type.ResponseTypeToken`.\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            scope: The scopes for the token.\n        Returns:\n            The new generated `aioauth.models.Token`.\n        \"\"\"\n        raise NotImplementedError(\"Method create_token must be implemented\")\n\n    async def get_token(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        token_type: Optional[TokenType] = None,\n        access_token: Optional[str] = None,\n        refresh_token: Optional[str] = None,\n    ) -&gt; Optional[Token]:\n        \"\"\"Gets existing token from the database.\n\n        Note:\n            Method is used by\n            `aioauth.server.AuthorizationServer`,  and by the\n            grant type `aioauth.grant_types.RefreshTokenGrantType`.\n        Args:\n            request: An `aioauth.requests.Request`.\n            client_id: A user client ID.\n            access_token: The user access token.\n            refresh_token: The user refresh token.\n        Returns:\n            An optional `aioauth.models.Token` object.\n        \"\"\"\n        raise NotImplementedError(\"Method get_token must be implemented\")\n\n    async def revoke_token(\n        self,\n        *,\n        request: Request,\n        client_id: str,\n        refresh_token: Optional[str] = None,\n        token_type: Optional[TokenType] = None,\n        access_token: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Revokes a token from the database.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.TokenStorage.create_token","title":"<code>create_token(*, request, client_id, scope, access_token, refresh_token=None)</code>  <code>async</code>","text":"<p>Generates a user token and stores it in the database.</p> <p>Used by:</p> <ul> <li><code>ResponseTypeToken</code></li> <li><code>AuthorizationCodeGrantType</code></li> <li><code>PasswordGrantType</code></li> <li><code>ClientCredentialsGrantType</code></li> <li><code>RefreshTokenGrantType</code></li> </ul> Warning <p>Generated token must be stored in the database.</p> <p>Note:     Method is used by all core grant types, but only used for     <code>aioauth.response_type.ResponseTypeToken</code>. Args:     request: An <code>aioauth.requests.Request</code>.     client_id: A user client ID.     scope: The scopes for the token. Returns:     The new generated <code>aioauth.models.Token</code>.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def create_token(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    scope: str,\n    access_token: str,\n    refresh_token: Optional[str] = None,\n) -&gt; Token:\n    \"\"\"Generates a user token and stores it in the database.\n\n    Used by:\n\n    * `ResponseTypeToken`\n    * `AuthorizationCodeGrantType`\n    * `PasswordGrantType`\n    * `ClientCredentialsGrantType`\n    * `RefreshTokenGrantType`\n\n    Warning:\n        Generated token *must* be stored in the database.\n    Note:\n        Method is used by all core grant types, but only used for\n        `aioauth.response_type.ResponseTypeToken`.\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        scope: The scopes for the token.\n    Returns:\n        The new generated `aioauth.models.Token`.\n    \"\"\"\n    raise NotImplementedError(\"Method create_token must be implemented\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.TokenStorage.get_token","title":"<code>get_token(*, request, client_id, token_type=None, access_token=None, refresh_token=None)</code>  <code>async</code>","text":"<p>Gets existing token from the database.</p> Note <p>Method is used by <code>aioauth.server.AuthorizationServer</code>,  and by the grant type <code>aioauth.grant_types.RefreshTokenGrantType</code>.</p> <p>Args:     request: An <code>aioauth.requests.Request</code>.     client_id: A user client ID.     access_token: The user access token.     refresh_token: The user refresh token. Returns:     An optional <code>aioauth.models.Token</code> object.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def get_token(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    token_type: Optional[TokenType] = None,\n    access_token: Optional[str] = None,\n    refresh_token: Optional[str] = None,\n) -&gt; Optional[Token]:\n    \"\"\"Gets existing token from the database.\n\n    Note:\n        Method is used by\n        `aioauth.server.AuthorizationServer`,  and by the\n        grant type `aioauth.grant_types.RefreshTokenGrantType`.\n    Args:\n        request: An `aioauth.requests.Request`.\n        client_id: A user client ID.\n        access_token: The user access token.\n        refresh_token: The user refresh token.\n    Returns:\n        An optional `aioauth.models.Token` object.\n    \"\"\"\n    raise NotImplementedError(\"Method get_token must be implemented\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.TokenStorage.revoke_token","title":"<code>revoke_token(*, request, client_id, refresh_token=None, token_type=None, access_token=None)</code>  <code>async</code>","text":"<p>Revokes a token from the database.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def revoke_token(\n    self,\n    *,\n    request: Request,\n    client_id: str,\n    refresh_token: Optional[str] = None,\n    token_type: Optional[TokenType] = None,\n    access_token: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Revokes a token from the database.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.UserStorage","title":"<code>UserStorage</code>","text":"Source code in <code>aioauth/storage.py</code> <pre><code>class UserStorage:\n    async def get_user(self, request: Request) -&gt; Optional[Any]:\n        \"\"\"Returns a user.\n\n        Note:\n            This method is used by the grant type\n            `aioauth.grant_type.PasswordGrantType`.\n\n        Args:\n            request: An `aioauth.requests.Request`.\n\n        Returns:\n            Boolean indicating whether or not the user was authenticated\n            successfully.\n        \"\"\"\n        raise NotImplementedError(\"Method get_user must be implemented\")\n</code></pre>"},{"location":"sections/api/storage/#aioauth.storage.UserStorage.get_user","title":"<code>get_user(request)</code>  <code>async</code>","text":"<p>Returns a user.</p> Note <p>This method is used by the grant type <code>aioauth.grant_type.PasswordGrantType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An <code>aioauth.requests.Request</code>.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Boolean indicating whether or not the user was authenticated</p> <code>Optional[Any]</code> <p>successfully.</p> Source code in <code>aioauth/storage.py</code> <pre><code>async def get_user(self, request: Request) -&gt; Optional[Any]:\n    \"\"\"Returns a user.\n\n    Note:\n        This method is used by the grant type\n        `aioauth.grant_type.PasswordGrantType`.\n\n    Args:\n        request: An `aioauth.requests.Request`.\n\n    Returns:\n        Boolean indicating whether or not the user was authenticated\n        successfully.\n    \"\"\"\n    raise NotImplementedError(\"Method get_user must be implemented\")\n</code></pre>"},{"location":"sections/api/types/","title":"Types","text":"<p>Containers that contain constants used throughout the project. <pre><code>from aioauth import types\n</code></pre></p>"},{"location":"sections/api/utils/","title":"Utils","text":"<p>Contains helper functions that is used throughout the project that doesn't pertain to a specific file or module. <pre><code>from aioauth import utils\n</code></pre></p>"},{"location":"sections/api/utils/#aioauth.utils.build_error_response","title":"<code>build_error_response(exc, request, skip_redirect_on_exc=(OAuth2Error,))</code>","text":"<p>Generate an OAuth HTTP response from the given exception</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>Exception used to generate HTTP response</p> required <code>request</code> <code>Request</code> <p>oauth request object</p> required <code>skip_redirect_on_exc</code> <code>Tuple[Type[OAuth2Error], ...]</code> <p>Exception types to skip redirect on</p> <code>(OAuth2Error,)</code> <p>Returns:</p> Type Description <code>Response</code> <p>OAuth HTTP response</p> Source code in <code>aioauth/utils.py</code> <pre><code>def build_error_response(\n    exc: Exception,\n    request: Request,\n    skip_redirect_on_exc: Tuple[Type[OAuth2Error], ...] = (OAuth2Error,),\n) -&gt; Response:\n    \"\"\"\n    Generate an OAuth HTTP response from the given exception\n\n    Args:\n        exc: Exception used to generate HTTP response\n        request: oauth request object\n        skip_redirect_on_exc: Exception types to skip redirect on\n\n    Returns:\n        OAuth HTTP response\n    \"\"\"\n    error: Union[TemporarilyUnavailableError, ServerError]\n    if isinstance(exc, skip_redirect_on_exc):\n        content = ErrorResponse(error=exc.error, description=exc.description)\n        log.debug(\"%s %r\", exc, request)\n        return Response(\n            content=asdict(content),\n            status_code=exc.status_code,\n            headers=exc.headers,\n        )\n    if isinstance(exc, OAuth2Error):\n        log.debug(\"%s %r\", exc, request)\n        query: Dict[str, str] = {\"error\": exc.error}\n        if exc.description:\n            query[\"error_description\"] = exc.description\n        if request.settings.ERROR_URI:\n            query[\"error_uri\"] = request.settings.ERROR_URI\n        if exc.state:\n            query[\"state\"] = exc.state\n        location = build_uri(request.query.redirect_uri, query)\n        return Response(\n            status_code=HTTPStatus.FOUND,\n            headers=HTTPHeaderDict({\"location\": location}),\n        )\n    error = ServerError(request=request)\n    log.exception(\"Exception caught while processing request.\", exc_info=exc)\n    content = ErrorResponse(error=error.error, description=error.description)\n    return Response(\n        content=asdict(content),\n        status_code=error.status_code,\n        headers=error.headers,\n    )\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.build_uri","title":"<code>build_uri(url, query_params=None, fragment=None)</code>","text":"<p>Builds an URI string from passed <code>url</code>, <code>query_params</code>, and <code>fragment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL string.</p> required <code>query_params</code> <code>Optional[Dict]</code> <p>Paramaters that contain the query.</p> <code>None</code> <code>fragment</code> <code>Optional[Dict]</code> <p>Fragment of the page.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>URL containing the original <code>url</code>, and the added</p> <code>str</code> <p><code>query_params</code> and <code>fragment</code>.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def build_uri(\n    url: str, query_params: Optional[Dict] = None, fragment: Optional[Dict] = None\n) -&gt; str:\n    \"\"\"\n    Builds an URI string from passed `url`, `query_params`, and\n    ``fragment``.\n\n    Args:\n        url: URL string.\n        query_params: Paramaters that contain the query.\n        fragment: Fragment of the page.\n\n    Returns:\n        URL containing the original `url`, and the added\n        `query_params` and `fragment`.\n    \"\"\"\n    if query_params is None:\n        query_params = {}\n\n    if fragment is None:\n        fragment = {}\n\n    parsed_url = urlparse(url)\n    parsed_params = {k: v[0] for k, v in parse_qs(parsed_url.query or \"\").items()}\n    query_params = {**parsed_params, **query_params}\n\n    uri = urlunsplit(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            urlencode(query_params, quote_via=quote),\n            urlencode(fragment, quote_via=quote),\n        )\n    )\n    return uri\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.catch_errors_and_unavailability","title":"<code>catch_errors_and_unavailability(skip_redirect_on_exc=(OAuth2Error,))</code>","text":"<p>Decorator that adds error catching to the function passed.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>A callable.</p> required <p>Returns:</p> Type Description <code>Callable[..., Callable[..., Coroutine[Any, Any, Response]]]</code> <p>A callable with error catching capabilities.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def catch_errors_and_unavailability(\n    skip_redirect_on_exc: Tuple[Type[OAuth2Error], ...] = (OAuth2Error,)\n) -&gt; Callable[..., Callable[..., Coroutine[Any, Any, Response]]]:\n    \"\"\"\n    Decorator that adds error catching to the function passed.\n\n    Args:\n        f: A callable.\n\n    Returns:\n        A callable with error catching capabilities.\n    \"\"\"\n\n    def decorator(\n        f: Callable[..., Coroutine[Any, Any, Response]]\n    ) -&gt; Callable[..., Coroutine[Any, Any, Response]]:\n        @functools.wraps(f)\n        async def wrapper(self, request: Request, *args, **kwargs) -&gt; Response:\n            try:\n                response = await f(self, request, *args, **kwargs)\n            except Exception as exc:\n                response = build_error_response(\n                    exc=exc, request=request, skip_redirect_on_exc=skip_redirect_on_exc\n                )\n            return response\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.create_s256_code_challenge","title":"<code>create_s256_code_challenge(code_verifier)</code>","text":"<p>Create S256 code challenge with the passed <code>code_verifier</code>.</p> Note <p>This function implements: <code>base64url(sha256(ascii(code_verifier)))</code>.</p> <p>Args:     code_verifier: Code verifier string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Representation of the S256 code challenge with the passed</p> <code>str</code> <p><code>code_verifier</code>.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def create_s256_code_challenge(code_verifier: str) -&gt; str:\n    \"\"\"\n    Create S256 code challenge with the passed `code_verifier`.\n\n    Note:\n        This function implements: `base64url(sha256(ascii(code_verifier)))`.\n    Args:\n        code_verifier: Code verifier string.\n\n    Returns:\n        Representation of the S256 code challenge with the passed\n        `code_verifier`.\n    \"\"\"\n    code_verifier_bytes = code_verifier.encode(\"utf-8\")\n    data = hashlib.sha256(code_verifier_bytes).digest()\n    return base64.urlsafe_b64encode(data).rstrip(b\"=\").decode()\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.decode_auth_headers","title":"<code>decode_auth_headers(authorization)</code>","text":"<p>Decodes an encoded HTTP basic authentication string. Returns a tuple of the form <code>(client_id, client_secret)</code>, and raises a <code>aioauth.errors.InvalidClientError</code> exception if nothing could be decoded.</p> <p>Parameters:</p> Name Type Description Default <code>authorization</code> <code>str</code> <p>Authorization header string.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of the form <code>(client_id, client_secret)</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid <code>authorization</code> header string.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def decode_auth_headers(authorization: str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Decodes an encoded HTTP basic authentication string.\n    Returns a tuple of the form ``(client_id, client_secret)``, and\n    raises a `aioauth.errors.InvalidClientError` exception if nothing\n    could be decoded.\n\n    Args:\n        authorization: Authorization header string.\n\n    Returns:\n        Tuple of the form `(client_id, client_secret)`.\n\n    Raises:\n        ValueError: Invalid `authorization` header string.\n    \"\"\"\n    scheme, param = get_authorization_scheme_param(authorization)\n    if not authorization or scheme.lower() != \"basic\":\n        raise ValueError(\"Invalid authorization header string.\")\n\n    try:\n        data = b64decode(param).decode(\"ascii\")\n    except (ValueError, UnicodeDecodeError, binascii.Error) as exc:\n        raise ValueError(\"Invalid base64 encoding.\") from exc\n\n    client_id, separator, client_secret = data.partition(\":\")\n\n    if not separator:\n        raise ValueError(\"Separator was not provided.\")\n\n    return client_id, client_secret\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.encode_auth_headers","title":"<code>encode_auth_headers(client_id, client_secret)</code>","text":"<p>Encodes the authentication header using base64 encoding.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client's id.</p> required <code>client_secret</code> <code>str</code> <p>The client's secret.</p> required <p>Returns:</p> Type Description <code>HTTPHeaderDict</code> <p>A case insensitive dictionary that contains the</p> <code>HTTPHeaderDict</code> <p><code>Authorization</code> header set to <code>basic</code> and the authorization</p> <code>HTTPHeaderDict</code> <p>header.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def encode_auth_headers(client_id: str, client_secret: str) -&gt; HTTPHeaderDict:\n    \"\"\"\n    Encodes the authentication header using base64 encoding.\n\n    Args:\n        client_id: The client's id.\n        client_secret: The client's secret.\n\n    Returns:\n        A case insensitive dictionary that contains the\n        `Authorization` header set to `basic` and the authorization\n        header.\n    \"\"\"\n    authorization = b64encode(f\"{client_id}:{client_secret}\".encode(\"ascii\"))\n    return HTTPHeaderDict(Authorization=f\"basic {authorization.decode()}\")\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.enforce_list","title":"<code>enforce_list(scope)</code>","text":"<p>Converts a space separated string to a list of scopes.</p> Note <p>If an iterable is passed to this method it will return a list representation of the iterable. Use <code>enforce_str</code> to convert iterables to a scope string.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>Optional[Union[str, List, Set, Tuple]]</code> <p>An iterable or string that contains scopes.</p> required <p>Returns:</p> Type Description <code>List</code> <p>A list of scopes.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def enforce_list(scope: Optional[Union[str, List, Set, Tuple]]) -&gt; List:\n    \"\"\"\n    Converts a space separated string to a list of scopes.\n\n    Note:\n        If an iterable is passed to this method it will return a list\n        representation of the iterable. Use `enforce_str` to\n        convert iterables to a scope string.\n\n    Args:\n        scope: An iterable or string that contains scopes.\n\n    Returns:\n        A list of scopes.\n    \"\"\"\n    if isinstance(scope, (tuple, list, set)):\n        return [str(s) for s in scope]\n    elif scope is None:\n        return []\n    else:\n        return scope.strip().split(\" \")\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.enforce_str","title":"<code>enforce_str(scope)</code>","text":"<p>Converts a list of scopes to a space separated string.</p> Note <p>If a string is passed to this method it will simply return an empty string back. Use <code>enforce_list</code> to convert strings to scope lists.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>List</code> <p>An iterable or string that contains a list of scope.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string of scopes seperated by spaces.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>The <code>scope</code> value passed is not of the proper type.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def enforce_str(scope: List) -&gt; str:\n    \"\"\"\n    Converts a list of scopes to a space separated string.\n\n    Note:\n        If a string is passed to this method it will simply return an\n        empty string back. Use `enforce_list` to convert\n        strings to scope lists.\n\n    Args:\n        scope: An iterable or string that contains a list of scope.\n\n    Returns:\n        A string of scopes seperated by spaces.\n\n    Raises:\n        TypeError: The `scope` value passed is not of the proper type.\n    \"\"\"\n    if isinstance(scope, (set, tuple, list)):\n        return \" \".join([str(s) for s in scope])\n\n    return \"\"\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.generate_token","title":"<code>generate_token(length=30, chars=UNICODE_ASCII_CHARACTER_SET)</code>","text":"<p>Generates a non-guessable OAuth token. OAuth (1 and 2) does not specify the format of tokens except that they should be strings of random characters. Tokens should not be guessable and entropy when generating the random characters is important. Which is why SystemRandom is used instead of the default random.choice method.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the generated token.</p> <code>30</code> <code>chars</code> <code>str</code> <p>The characters to use to generate the string.</p> <code>UNICODE_ASCII_CHARACTER_SET</code> <p>Returns:</p> Type Description <code>str</code> <p>Random string of length <code>length</code> and characters in <code>chars</code>.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def generate_token(length: int = 30, chars: str = UNICODE_ASCII_CHARACTER_SET) -&gt; str:\n    \"\"\"Generates a non-guessable OAuth token.\n    OAuth (1 and 2) does not specify the format of tokens except that\n    they should be strings of random characters. Tokens should not be\n    guessable and entropy when generating the random characters is\n    important. Which is why SystemRandom is used instead of the default\n    random.choice method.\n\n    Args:\n        length: Length of the generated token.\n        chars: The characters to use to generate the string.\n\n    Returns:\n        Random string of length `length` and characters in `chars`.\n    \"\"\"\n    rand = random.SystemRandom()\n    return \"\".join(rand.choice(chars) for _ in range(length))\n</code></pre>"},{"location":"sections/api/utils/#aioauth.utils.get_authorization_scheme_param","title":"<code>get_authorization_scheme_param(authorization_header_value)</code>","text":"<p>Retrieves the authorization schema parameters from the authorization header.</p> <p>Parameters:</p> Name Type Description Default <code>authorization_header_value</code> <code>str</code> <p>Value of the authorization header.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of the format <code>(scheme, param)</code>.</p> Source code in <code>aioauth/utils.py</code> <pre><code>def get_authorization_scheme_param(\n    authorization_header_value: str,\n) -&gt; Tuple[str, str]:\n    \"\"\"\n    Retrieves the authorization schema parameters from the authorization\n    header.\n\n    Args:\n        authorization_header_value: Value of the authorization header.\n\n    Returns:\n        Tuple of the format `(scheme, param)`.\n    \"\"\"\n    if not authorization_header_value:\n        return \"\", \"\"\n    scheme, _, param = authorization_header_value.partition(\" \")\n    return scheme, param\n</code></pre>"},{"location":"sections/api/oidc/core/grant_type/","title":"Grant Type","text":"<p>Different OAuth 2.0 grant types with OpenID Connect extensions.</p> <pre><code>from aioauth.oidc.core import grant_type\n</code></pre>"},{"location":"sections/api/oidc/core/grant_type/#aioauth.oidc.core.grant_type.AuthorizationCodeGrantType","title":"<code>AuthorizationCodeGrantType</code>","text":"<p>               Bases: <code>AuthorizationCodeGrantType</code></p> <p>The Authorization Code grant type is used by confidential and public clients to exchange an authorization code for an access token. After the user returns to the client via the redirect URL, the application will get the authorization code from the URL and use it to request an access token. It is recommended that all clients use RFC 7636. Proof Key for Code Exchange extension with this flow as well to provide better security.</p> Note <p>Note that <code>aioauth</code> implements RFC 7636 out-of-the-box. See RFC 6749 section 1.3.1.</p> Source code in <code>aioauth/oidc/core/grant_type.py</code> <pre><code>class AuthorizationCodeGrantType(OAuth2AuthorizationCodeGrantType):\n    \"\"\"\n    The Authorization Code grant type is used by confidential and public\n    clients to exchange an authorization code for an access token. After\n    the user returns to the client via the redirect URL, the application\n    will get the authorization code from the URL and use it to request\n    an access token.\n    It is recommended that all clients use [RFC 7636](https://tools.ietf.org/html/rfc7636).\n    Proof Key for Code Exchange extension with this flow as well to\n    provide better security.\n\n    Note:\n        Note that `aioauth` implements RFC 7636 out-of-the-box.\n        See [RFC 6749 section 1.3.1](https://tools.ietf.org/html/rfc6749#section-1.3.1).\n    \"\"\"\n\n    async def create_token_response(\n        self, request: Request, client: Client\n    ) -&gt; TokenResponse:\n        \"\"\"\n        Creates token response to reply to client.\n\n        Extends the OAuth2 authorization_code grant type such that an id_token\n        is always included with the access_token.\n\n        See: [https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse](https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse)\n        \"\"\"\n        if self.scope is None:\n            raise RuntimeError(\"validate_request() must be called first\")\n\n        token = await self.storage.create_token(\n            request=request,\n            client_id=client.client_id,\n            scope=self.scope,\n            access_token=generate_token(42),\n            refresh_token=generate_token(48),\n        )\n\n        if TYPE_CHECKING:\n            # validate_request will have already ensured the request includes a code.\n            assert request.post.code is not None\n\n        authorization_code = await self.storage.get_authorization_code(\n            request=request,\n            client_id=client.client_id,\n            code=request.post.code,\n        )\n\n        if TYPE_CHECKING:\n            # validate_request will have already ensured the code was valid.\n            assert authorization_code is not None\n\n        id_token = await self.storage.get_id_token(\n            client_id=client.client_id,\n            nonce=authorization_code.nonce,\n            redirect_uri=request.query.redirect_uri,\n            request=request,\n            response_type=\"code\",\n            scope=self.scope,\n        )\n\n        await self.storage.delete_authorization_code(\n            request=request,\n            client_id=client.client_id,\n            code=request.post.code,\n        )\n\n        return TokenResponse(\n            access_token=token.access_token,\n            expires_in=token.expires_in,\n            id_token=id_token,\n            refresh_token=token.refresh_token,\n            refresh_token_expires_in=token.refresh_token_expires_in,\n            scope=token.scope,\n            token_type=token.token_type,\n        )\n</code></pre>"},{"location":"sections/api/oidc/core/grant_type/#aioauth.oidc.core.grant_type.AuthorizationCodeGrantType.create_token_response","title":"<code>create_token_response(request, client)</code>  <code>async</code>","text":"<p>Creates token response to reply to client.</p> <p>Extends the OAuth2 authorization_code grant type such that an id_token is always included with the access_token.</p> <p>See: https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse</p> Source code in <code>aioauth/oidc/core/grant_type.py</code> <pre><code>async def create_token_response(\n    self, request: Request, client: Client\n) -&gt; TokenResponse:\n    \"\"\"\n    Creates token response to reply to client.\n\n    Extends the OAuth2 authorization_code grant type such that an id_token\n    is always included with the access_token.\n\n    See: [https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse](https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse)\n    \"\"\"\n    if self.scope is None:\n        raise RuntimeError(\"validate_request() must be called first\")\n\n    token = await self.storage.create_token(\n        request=request,\n        client_id=client.client_id,\n        scope=self.scope,\n        access_token=generate_token(42),\n        refresh_token=generate_token(48),\n    )\n\n    if TYPE_CHECKING:\n        # validate_request will have already ensured the request includes a code.\n        assert request.post.code is not None\n\n    authorization_code = await self.storage.get_authorization_code(\n        request=request,\n        client_id=client.client_id,\n        code=request.post.code,\n    )\n\n    if TYPE_CHECKING:\n        # validate_request will have already ensured the code was valid.\n        assert authorization_code is not None\n\n    id_token = await self.storage.get_id_token(\n        client_id=client.client_id,\n        nonce=authorization_code.nonce,\n        redirect_uri=request.query.redirect_uri,\n        request=request,\n        response_type=\"code\",\n        scope=self.scope,\n    )\n\n    await self.storage.delete_authorization_code(\n        request=request,\n        client_id=client.client_id,\n        code=request.post.code,\n    )\n\n    return TokenResponse(\n        access_token=token.access_token,\n        expires_in=token.expires_in,\n        id_token=id_token,\n        refresh_token=token.refresh_token,\n        refresh_token_expires_in=token.refresh_token_expires_in,\n        scope=token.scope,\n        token_type=token.token_type,\n    )\n</code></pre>"},{"location":"sections/api/oidc/core/requests/","title":"Requests","text":"<p>Different OAuth 2.0 request with OpenID Connect extensions.</p> <pre><code>from aioauth.oidc.core import requests\n</code></pre>"},{"location":"sections/api/oidc/core/requests/#aioauth.oidc.core.requests.Query","title":"<code>Query</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Query</code></p> <p>Query extended with OpenID <code>prompt</code></p> Source code in <code>aioauth/oidc/core/requests.py</code> <pre><code>@dataclass\nclass Query(BaseQuery):\n    \"\"\"Query extended with OpenID `prompt`\"\"\"\n\n    # Space delimited, case sensitive list of ASCII string values that\n    # specifies whether the Authorization Server prompts the End-User for\n    # reauthentication and consent. The defined values are: none, login,\n    # consent, select_account.\n    # https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\n    prompt: Optional[str] = None\n</code></pre>"},{"location":"sections/api/oidc/core/requests/#aioauth.oidc.core.requests.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Object that contains a client's complete request.</p> Source code in <code>aioauth/oidc/core/requests.py</code> <pre><code>@dataclass\nclass Request(BaseRequest):\n    \"\"\"Object that contains a client's complete request.\"\"\"\n\n    query: Query = field(default_factory=Query)\n</code></pre>"},{"location":"sections/api/oidc/core/responses/","title":"Responses","text":"<p>Different OAuth 2.0 responses with OpenID Connect extensions.</p> <pre><code>from aioauth.oidc.core import responses\n</code></pre>"},{"location":"sections/api/oidc/core/responses/#aioauth.oidc.core.responses.TokenResponse","title":"<code>TokenResponse</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TokenResponse</code></p> <p>Token response extended with OpenID <code>id_token</code></p> Source code in <code>aioauth/oidc/core/responses.py</code> <pre><code>@dataclass\nclass TokenResponse(OAuthTokenResponse):\n    \"\"\"Token response extended with OpenID `id_token`\"\"\"\n\n    id_token: Optional[str] = None\n</code></pre>"},{"location":"sections/quick_start/","title":"Quick Start","text":"<p>To help you get started, we've provided a working example of aioauth integrated into a minimal FastAPI server using an in-memory database. While the example is intentionally simple, it demonstrates a fully functional flow and can serve as a solid foundation. You can later adapt and extend it into a full production-ready solution tailored to your needs.</p>"},{"location":"sections/quick_start/#installation","title":"Installation","text":"<pre><code>$ git clone git@github.com:aliev/aioauth.git\n$ cd aioauth/examples\n$ pip install -r requirements.txt\n$ python3 fastapi_example.py\n</code></pre>"},{"location":"sections/quick_start/#testing","title":"Testing","text":"<p>Initialize an <code>authorization_code</code> request with the example server.</p> <pre><code>http://localhost:8000/oauth/authorize?client_id=test_client&amp;redirect_uri=https%3A%2F%2Fwww.example.com%2Fredirect&amp;response_type=code&amp;state=somestate&amp;scope=email\n</code></pre> <p>The oauth server authenticates the resource owner (via a login form).</p> <p></p> <p>The oauth server then checks whether the resource owner approves or denies the client's access request.</p> <p></p> <p>The oauth server will then generate a response as a redirect to the specified <code>redirect_uri</code> in the initial request. If there is an error with the initial client request, or the resource owner denies the request the server will respond with an error, otherwise it will return a success with a generated \"authorization-code\"</p> <p>An error response would look something like this:</p> <pre><code>https://www.example.com/redirect?error=access_denied&amp;state=somestate\n</code></pre> <p>Whilst a success looks like this:</p> <pre><code>https://www.example.com/redirect?state=somestate&amp;code=EJKOGQhY7KcWjNGI2UbCnOrqAGtRiCEJnAYNwYJ8M5&amp;scope=email\n</code></pre> <p>The client can then request an access-token in exchange for the authorization-code using the servers token endpoint.</p> <pre><code>curl localhost:8000/oauth/tokenize \\\n    -u 'test_client:password' \\\n    -d 'grant_type=authorization_code' \\\n    -d 'code=EJKOGQhY7KcWjNGI2UbCnOrqAGtRiCEJnAYNwYJ8M5'\\\n    -d 'redirect_uri=https://www.example.com/redirect'\n</code></pre> <p>The server then responds with the associated <code>access_token</code>, <code>refresh_token</code>, and its relevant data:</p> <pre><code>{\n    \"expires_in\": 300,\n    \"refresh_token_expires_in\": 900,\n    \"access_token\": \"TIQdQv5FCyBoFtoeGt1tAJ37EJdggl8xgSvCVbdjqD\",\n    \"refresh_token\": \"iJD7Yf4SFuSljmXOhyfjfZelc5J0uIe2P4hwGm4wORCDJyrT\",\n    \"scope\": \"email\",\n    \"token_type\": \"Bearer\"\n}\n</code></pre> <p>The access-token may be replaced/renewed using the specified <code>refresh_token</code> using the <code>refresh_token</code> grant type, which returns the same set of data before with new tokens.</p> <pre><code>curl localhost:8000/oauth/tokenize \\\n    -u 'test_client:password' \\\n    -d 'grant_type=refresh_token' \\\n    -d 'refresh_token=iJD7Yf4SFuSljmXOhyfjfZelc5J0uIe2P4hwGm4wORCDJyrT'\n</code></pre>"}]}